<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LingoMate - Language Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.26.2/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .mobile-hide-scrollbar::-webkit-scrollbar { display: none; }
            .mobile-hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        }
        body { font-family: 'Inter', sans-serif; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f9fafb; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        .fade-in { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        
        .dictation-input {
            width: 1.4rem;
            height: 2rem;
            text-align: center;
            border-bottom: 2px solid #e5e7eb;
            background: transparent;
            font-size: 1rem;
            font-weight: 600;
            outline: none;
            transition: all 0.2s;
            margin: 0 1px;
        }
        /* NEW: Specific style for the space input */
        /* Updated Space Style: Transparent border so it's invisible but holds space */
        .dictation-space {
            width: 1rem;       /* Slightly narrower */
            border-bottom: 2px solid transparent; /* Hide the line */
            margin: 0 2px;
            transition: all 0.2s;
        }
        
        /* NEW: Class for punctuation to hide lines */
        .dictation-no-border {
            border-bottom-color: transparent !important;
        }

       /* 1. Standard Input Focus: Dark line */
        .dictation-input:focus { 
            border-bottom-color: #000; 
            background: #f9fafb; 
        }

        /* 2. Space Input Focus: KEEP TRANSPARENT (Fixes the visible line issue) */
        .dictation-space:focus { 
            border-bottom-color: transparent !important; 
            background: #f9fafb; /* Optional: Keep background so cursor is visible */
            outline: none;       /* Remove default browser outline */
        }

        .dictation-input:focus, .dictation-space:focus { border-bottom-color: #000; background: #f9fafb; }
        .dictation-input.correct, .dictation-space.correct { color: #059669; border-bottom-color: #059669; }
        .dictation-input.incorrect, .dictation-space.incorrect { color: #dc2626; border-bottom-color: #dc2626; }

        .share-toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp { from { transform: translate(-50%, 100%); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }
    </style>
</head>
<body class="bg-white text-gray-900 h-screen flex flex-col overflow-hidden selection:bg-indigo-100 selection:text-indigo-900">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.3.1';
        import { createRoot } from 'https://esm.sh/react-dom@18.3.1/client';
        import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
        import { 
            Play, Pause, ChevronRight, ChevronLeft, ChevronDown,
            Upload, FileText, History, Settings, 
            Repeat, Mic, Volume2, User, LogOut, Loader2, X, Database, Save, AlertCircle, 
            CheckCircle2, ArrowRight, Music, KeyRound, AlertTriangle, Trash2, SkipBack, 
            SkipForward, RefreshCw, PenTool, BookOpen, Layers, Square, Circle, Eye, 
            Book, Languages, Plus, Wand2, Check, ListChecks, Share2, Sparkles, Pencil, Clock, MoveRight, EyeOff
        } from 'https://esm.sh/lucide-react@0.344.0?deps=react@18.3.1';

        const SUPABASE_URL = 'https://tnwtvxmbjwbgiwruttju.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRud3R2eG1iandiZ2l3cnV0dGp1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU2NjYzNzgsImV4cCI6MjA4MTI0MjM3OH0.3AexQNzabxTLV2PbkusFwSZe7n1jsYDBJF7GB2SXhRk';
        const DEFAULT_API_KEY = "AIzaSyArbJjcdPrq74ABOW0jzL_xOh-xY0-JFQ0"; 

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- MODAL COMPONENTS ---
        const ModalLayout = ({ children, isOpen, onClose, title, icon: Icon }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/40 backdrop-blur-sm fade-in">
                    <div className="bg-white w-full max-w-md rounded-3xl shadow-2xl overflow-hidden">
                        <div className="px-6 py-4 border-b border-gray-100 flex items-center justify-between bg-gray-50/50">
                            <div className="flex items-center gap-2">
                                {Icon && <Icon className="w-5 h-5 text-black" />}
                                <h2 className="font-bold text-gray-800">{title}</h2>
                            </div>
                            <button onClick={onClose} className="p-2 hover:bg-gray-200 rounded-full transition-colors">
                                <X className="w-5 h-5 text-gray-500" />
                            </button>
                        </div>
                        <div className="p-6">{children}</div>
                    </div>
                </div>
            );
        };

        const LoginModal = ({ isOpen, onClose, onLogin }) => {
            const [mode, setMode] = useState('login');
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setLoading(true);
                setError(null);
                const err = await onLogin(email, password, mode);
                if (err) setError(err);
                setLoading(false);
            };

            return (
                <ModalLayout isOpen={isOpen} onClose={onClose} title={mode === 'login' ? "Sign In" : "Sign Up"} icon={User}>
                    <form onSubmit={handleSubmit} className="space-y-4">
                        {error && <div className="p-3 bg-red-50 text-red-600 text-xs rounded-xl font-medium">{error}</div>}
                        <div>
                            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Email</label>
                            <input type="email" required className="w-full px-4 py-3 bg-gray-50 border-none rounded-xl text-sm outline-none focus:ring-2 focus:ring-black transition-all" value={email} onChange={e => setEmail(e.target.value)} />
                        </div>
                        <div>
                            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Password</label>
                            <input type="password" required className="w-full px-4 py-3 bg-gray-50 border-none rounded-xl text-sm outline-none focus:ring-2 focus:ring-black transition-all" value={password} onChange={e => setPassword(e.target.value)} />
                        </div>
                        <button type="submit" disabled={loading} className="w-full bg-black text-white py-4 font-bold rounded-xl flex items-center justify-center gap-2 hover:bg-gray-800 transition-all shadow-md">
                            {loading ? <Loader2 className="w-5 h-5 animate-spin" /> : mode === 'login' ? "Login" : "Register"}
                        </button>
                        <p className="text-center text-sm text-gray-500 pt-2">
                            {mode === 'login' ? "Don't have an account?" : "Already have an account?"}
                            <button type="button" onClick={() => setMode(mode === 'login' ? 'signup' : 'login')} className="ml-1 text-black font-bold hover:underline">
                                {mode === 'login' ? "Sign up" : "Sign in"}
                            </button>
                        </p>
                    </form>
                </ModalLayout>
            );
        };

        const SettingsModal = ({ isOpen, onClose, apiKey, onSave }) => {
            const [key, setKey] = useState(apiKey || '');
            return (
                <ModalLayout isOpen={isOpen} onClose={onClose} title="Settings" icon={Settings}>
                    <div className="space-y-4">
                        <div className="p-4 bg-blue-50 border border-blue-100 rounded-xl flex gap-3">
                            <AlertCircle className="w-5 h-5 text-blue-600 shrink-0" />
                            <p className="text-xs text-blue-800 leading-relaxed">Enter your Gemini API key to enable transcription and grammar analysis features.</p>
                        </div>
                        <div>
                            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Gemini API Key</label>
                            <input type="password" placeholder="AIza..." className="w-full px-4 py-3 bg-gray-50 border-none rounded-xl text-sm outline-none focus:ring-2 focus:ring-black transition-all" value={key} onChange={e => setKey(e.target.value)} />
                        </div>
                        <button onClick={() => { onSave(key); onClose(); }} className="w-full bg-black text-white py-4 font-bold rounded-xl hover:bg-gray-800 transition-all shadow-md">
                            Save Settings
                        </button>
                    </div>
                </ModalLayout>
            );
        };

        const VocabularyModal = ({ isOpen, onClose, words, onDelete }) => {
            return (
                <ModalLayout isOpen={isOpen} onClose={onClose} title="Vocabulary" icon={BookOpen}>
                    <div className="max-h-[400px] overflow-y-auto custom-scrollbar pr-2 space-y-3">
                        {words.length === 0 ? (
                            <div className="text-center py-10 text-gray-400 italic text-sm">Your list is empty</div>
                        ) : (
                            words.map(w => (
                                <div key={w.id} className="p-4 border border-gray-100 rounded-2xl bg-white shadow-sm flex justify-between items-start group">
                                    <div className="flex-1 min-w-0 pr-4">
                                        <p className="font-bold text-gray-900 truncate">{w.word}</p>
                                        <p className="text-sm text-gray-600 mt-1 line-clamp-2">{w.definition}</p>
                                    </div>
                                    <button onClick={() => onDelete(w.id)} className="p-2 text-gray-300 hover:text-red-500 transition-colors">
                                        <Trash2 className="w-4 h-4" />
                                    </button>
                                </div>
                            ))
                        )}
                    </div>
                </ModalLayout>
            );
        };

        const CreateCollectionModal = ({ isOpen, onClose, onCreate }) => {
            const [name, setName] = useState("");
            if (!isOpen) return null;
            return (
                <ModalLayout isOpen={isOpen} onClose={onClose} title="New Collection" icon={Layers}>
                    <div className="space-y-4">
                        <div>
                            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Collection Name</label>
                            <input autoFocus type="text" className="w-full px-4 py-3 bg-gray-50 border-none rounded-xl text-sm outline-none focus:ring-2 focus:ring-black" value={name} onChange={e => setName(e.target.value)} placeholder="e.g., French Lessons" />
                        </div>
                        <button onClick={() => { onCreate(name); setName(""); onClose(); }} disabled={!name.trim()} className="w-full bg-black text-white py-4 font-bold rounded-xl hover:bg-gray-800 disabled:opacity-50">Create Collection</button>
                    </div>
                </ModalLayout>
            );
        };

        const ShareCollectionModal = ({ isOpen, onClose, onShare }) => {
            const [email, setEmail] = useState("");
            const [isLoading, setIsLoading] = useState(false);

            const handleShare = async () => {
                setIsLoading(true);
                await onShare(email);
                setIsLoading(false);
                setEmail("");
                onClose();
            };

            if (!isOpen) return null;
            return (
                <ModalLayout isOpen={isOpen} onClose={onClose} title="Share Collection" icon={Share2}>
                    <div className="space-y-4">
                        <div className="p-4 bg-blue-50 border border-blue-100 rounded-xl flex gap-3">
                            <User className="w-5 h-5 text-blue-600 shrink-0" />
                            <p className="text-xs text-blue-800 leading-relaxed">Enter the email of the student or teacher you want to invite to this collection.</p>
                        </div>
                        <div>
                            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">User Email</label>
                            <input autoFocus type="email" className="w-full px-4 py-3 bg-gray-50 border-none rounded-xl text-sm outline-none focus:ring-2 focus:ring-black" value={email} onChange={e => setEmail(e.target.value)} placeholder="student@example.com" />
                        </div>
                        <button onClick={handleShare} disabled={!email.trim() || isLoading} className="w-full bg-black text-white py-4 font-bold rounded-xl hover:bg-gray-800 disabled:opacity-50 flex justify-center items-center gap-2">
                            {isLoading ? <Loader2 className="animate-spin w-4 h-4"/> : "Invite User"}
                        </button>
                    </div>
                </ModalLayout>
            );
        };
        
        const ConfirmModal = ({ isOpen, onClose, onConfirm, title, message }) => {
            return (
                <ModalLayout isOpen={isOpen} onClose={onClose} title={title} icon={AlertTriangle}>
                    <div className="space-y-6">
                        <p className="text-sm text-gray-600 leading-relaxed">{message}</p>
                        <div className="flex gap-3">
                            <button onClick={onClose} className="flex-1 py-3 bg-gray-100 text-gray-700 font-bold rounded-xl hover:bg-gray-200 transition-all text-sm">Cancel</button>
                            <button onClick={onConfirm} className="flex-1 py-3 bg-red-600 text-white font-bold rounded-xl hover:bg-red-700 transition-all text-sm">Confirm</button>
                        </div>
                    </div>
                </ModalLayout>
            );
        };

        // --- UTILS & HELPERS ---
        const Spinner = () => <Loader2 className="w-4 h-4 animate-spin" />;

        const sanitizeFilename = (filename) => filename.replace(/[^a-z0-9.]/gi, '_').replace(/_+/g, '_');

        const getMediaDuration = (file) => new Promise((resolve) => {
            const url = URL.createObjectURL(file);
            const media = file.type.startsWith('video/') ? document.createElement('video') : document.createElement('audio');
            media.src = url;
            media.onloadedmetadata = () => { URL.revokeObjectURL(url); resolve(media.duration); };
            media.onerror = () => resolve(0);
        });

        const fileToGenerativePart = async (file) => {
            const base64 = await new Promise(r => {
                const reader = new FileReader();
                reader.onloadend = () => r(reader.result.split(',')[1]);
                reader.readAsDataURL(file);
            });
            return { inlineData: { data: base64, mimeType: file.type || 'application/octet-stream' } };
        };

        const sanitizeTranscript = (rawSegments, totalDuration) => {
            if (!Array.isArray(rawSegments) || rawSegments.length === 0) return [];
            
            const sorted = rawSegments.sort((a, b) => a.start - b.start);
            let previousEnd = 0.0;

            return sorted.map((seg, index) => {
                let start = Number(seg.start);
                let end = Number(seg.end);

                if (index === 0) {
                    start = 0.0;
                } else {
                    start = previousEnd;
                }
                
                // Keep AI end time but ensure it doesn't overlap backwards
                if (end <= start) end = start + 0.5;

                previousEnd = end;

                return { start, end, text: seg.text, speaker: seg.speaker || "Speaker" };
            }).filter(Boolean);
        };

        const callGemini = async (apiKey, model, body) => {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error.message);
            if (!data.candidates) throw new Error("No response from AI");
            return data;
        };

        const processTranscription = async (apiKey, fileObject = null, contextText = "", totalDuration = 0) => {
            const effectiveKey = apiKey || DEFAULT_API_KEY;
            let parts = [];
            
            if (fileObject) {
                const filePart = await fileToGenerativePart(fileObject);
                parts = [filePart, { text: `You are a professional transcriber tool. 
I will provide an audio or video file. 
Your task is to transcribe it into English and provide precise timestamps for the start and end of every sentence.

STRICT REQUIREMENTS:
1. Output strictly a VALID JSON array of objects.
2. Format: [ { "text": "string", "start": number, "end": number } ]
3. Do not split sentences on abbreviations (e.g. Mr., Dr.).
4. Transcription must be verbatim.
                
Output JSON:` }];
            }

            let rawText = "";
            try {
                const data = await callGemini(effectiveKey, "gemini-2.5-flash-preview-09-2025", { 
                    contents: [{ parts: parts }], 
                    generationConfig: { temperature: 0.0, responseMimeType: "application/json" } 
                });
                rawText = data.candidates[0].content.parts[0].text;
            } catch (err) {
                console.warn("Gemini 2.5 failed, attempting fallback to 2.0", err);
                const data = await callGemini(effectiveKey, "gemini-2.5-flash-preview-09-2025", { 
                    contents: [{ parts: parts }], 
                    generationConfig: { temperature: 0.0, responseMimeType: "application/json" } 
                });
                rawText = data.candidates[0].content.parts[0].text;
            }
            
            let rawJson = [];
            try {
                const cleanText = rawText.replace(/```json|```/g, '').trim();
                rawJson = JSON.parse(cleanText);
            } catch (e) {
                const match = rawText.match(/\[.*\]/s);
                if (match) {
                    try { rawJson = JSON.parse(match[0]); } catch (e2) {}
                }
            }

            if (!Array.isArray(rawJson) || rawJson.length === 0) {
                 throw new Error("Failed to parse transcript. Please try again.");
            }

            return sanitizeTranscript(rawJson, totalDuration);
        };

        const fetchMeaningAndGrammar = async (apiKey, sentence) => {
            const effectiveKey = apiKey || DEFAULT_API_KEY;
            const body = {
                contents: [{ parts: [{ text: `Analyze the following English source sentence: "${sentence}". 
Provide:
1. Natural Chinese Translation (translation).
2. Explanation of the ENGLISH vocabulary, nuances, and meaning (explanation).
3. Analysis of the ENGLISH grammar structures (grammar).

IMPORTANT: Analyze the English source text, NOT the Chinese translation.
ALL EXPLANATIONS MUST BE IN CHINESE SIMPLIFIED (简体中文). 
Output strictly JSON: { "translation": "...", "explanation": "...", "grammar": "..." }.` }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            const data = await callGemini(effectiveKey, "gemini-2.5-flash-preview-09-2025", body);
            return JSON.parse(data.candidates[0].content.parts[0].text);
        };

        const fetchBatchReAnalysis = async (apiKey, fileObject, startTime, endTime, hint) => {
             const effectiveKey = apiKey || DEFAULT_API_KEY;
             const filePart = await fileToGenerativePart(fileObject);
             const body = {
                contents: [{ 
                    parts: [
                        filePart, 
                        { text: `Re-analyze accurately the audio between ${startTime.toFixed(2)}s and ${endTime.toFixed(2)}s. Correction hint: "${hint || 'None'}". Output strictly JSON as an array of logical segments: Array<{ text: string, start: number, end: number, speaker: string }>.` }
                    ] 
                }],
                generationConfig: { responseMimeType: "application/json" }
            };

            const data = await callGemini(effectiveKey, "gemini-2.5-flash-preview-09-2025", body);
            return JSON.parse(data.candidates[0].content.parts[0].text);
        };

        const SmartPlayer = ({ source, isPlaying, setIsPlaying, seekTime, onTimeUpdate, loopRange, seekTrigger }) => {
            const mediaRef = useRef(null);

            useEffect(() => {
                if (mediaRef.current) {
                    if (isPlaying) mediaRef.current.play().catch(() => setIsPlaying(false));
                    else mediaRef.current.pause();
                }
            }, [isPlaying]);

            useEffect(() => {
                if (mediaRef.current && seekTime !== undefined) {
                    mediaRef.current.currentTime = seekTime;
                }
            }, [seekTrigger]);

            if (source.mediaType === 'video') {
                return (
                    <div className="w-full aspect-video bg-black rounded-3xl overflow-hidden shadow-2xl relative border-4 border-white mb-4">
                        <video 
                            ref={mediaRef} 
                            src={source.url} 
                            className="w-full h-full object-contain"
                            playsInline // <--- THIS IS THE KEY FIX
                            webkit-playsinline="true" // Extra compatibility for older iOS
                            controls // Optional: You might want native controls on mobile
                            onTimeUpdate={(e) => onTimeUpdate(e.target.currentTime)}
                        />
                    </div>
                );
            }

            return (
                <audio 
                    ref={mediaRef} 
                    src={source.url} 
                    onTimeUpdate={(e) => onTimeUpdate(e.target.currentTime)}
                />
            );
        };

        // --- NEW: Word Analysis Helper ---
        const fetchWordDetails = async (apiKey, word, contextSentence) => {
            const effectiveKey = apiKey || DEFAULT_API_KEY;
            const body = {
                contents: [{ parts: [{ text: `
                    Analyze the English word "${word}" in the context of this sentence: "${contextSentence}".
                    Provide:
                    1. IPA Phonetic Transcription (ipa)
                    2. A concise definition in English (definition)
                    3. A generic example sentence using this word (example)
                    
                    Output strictly JSON: { "ipa": "/.../", "definition": "...", "example": "..." }
                ` }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            try {
                const data = await callGemini(effectiveKey, "gemini-2.5-flash-preview-09-2025", body);
                return JSON.parse(data.candidates[0].content.parts[0].text);
            } catch (e) {
                console.error("Word analysis failed", e);
                return { ipa: "", definition: "Could not fetch definition.", example: "" };
            }
        };

        // --- NEW: Interactive Text Component ---
        // Splits text into words and punctuation, making words clickable
        const InteractiveText = ({ text, onWordClick, className = "" }) => {
            if (!text) return null;
            // Split by words (alphanumeric + apostrophes/dashes) while keeping delimiters
            const parts = text.split(/([a-zA-Z0-9']+(?:-[a-zA-Z0-9']+)*)/);
            
            return (
                <div className={`inline-block leading-relaxed ${className}`}>
                    {parts.map((part, i) => {
                        // Check if part is a word (starts with letter/number)
                        const isWord = /^[a-zA-Z0-9]/.test(part);
                        if (isWord) {
                            return (
                                <span 
                                    key={i} 
                                    onClick={(e) => { e.stopPropagation(); onWordClick(part); }}
                                    className="cursor-pointer hover:bg-yellow-200 hover:text-black rounded px-0.5 transition-colors border-b border-transparent hover:border-black/20"
                                >
                                    {part}
                                </span>
                            );
                        }
                        return <span key={i}>{part}</span>;
                    })}
                </div>
            );
        };

        // --- NEW: Word Detail Popup ---
        const WordDetailModal = ({ isOpen, onClose, data, word, isLoading, onPlay, onAddVocab }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-black/20 backdrop-blur-[2px] fade-in" onClick={onClose}>
                    <div className="bg-white w-full max-w-sm rounded-2xl shadow-2xl overflow-hidden border border-gray-100" onClick={e => e.stopPropagation()}>
                        <div className="p-5 relative">
                            <button onClick={onClose} className="absolute top-3 right-3 p-1 text-gray-400 hover:bg-gray-100 rounded-full"><X size={16} /></button>
                            
                            <div className="flex items-baseline gap-3 mb-1">
                                <h3 className="text-2xl font-bold text-gray-900">{word}</h3>
                                {!isLoading && data?.ipa && <span className="text-sm font-mono text-gray-500">{data.ipa}</span>}
                            </div>

                            {/* Actions Row */}
                            <div className="flex gap-2 mb-4">
                                <button onClick={() => onPlay(word)} className="p-2 bg-indigo-50 text-indigo-600 rounded-lg hover:bg-indigo-100 transition-colors flex items-center gap-2 text-xs font-bold">
                                    <Volume2 size={14} /> Listen
                                </button>
                                <button onClick={() => { onAddVocab(); onClose(); }} className="p-2 bg-emerald-50 text-emerald-600 rounded-lg hover:bg-emerald-100 transition-colors flex items-center gap-2 text-xs font-bold">
                                    <Plus size={14} /> Add to Vocab
                                </button>
                            </div>

                            {isLoading ? (
                                <div className="py-8 flex flex-col items-center justify-center text-gray-400 gap-2">
                                    <Loader2 className="w-6 h-6 animate-spin text-indigo-500" />
                                    <span className="text-xs">Analyzing context...</span>
                                </div>
                            ) : (
                                <div className="space-y-3 animate-in fade-in">
                                    <div className="bg-gray-50 p-3 rounded-xl border border-gray-100">
                                        <p className="text-sm text-gray-700 leading-relaxed font-medium">{data.definition}</p>
                                    </div>
                                    {data.example && (
                                        <div className="pl-2 border-l-2 border-indigo-200">
                                            <p className="text-xs text-gray-500 italic">"{data.example}"</p>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const formatTime = (s) => {
            if (s === undefined || s === null) return "0:00.000";
            const mins = Math.floor(s / 60);
            const secs = Math.floor(s % 60);
            const ms = Math.floor((s % 1) * 1000);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        };

        // --- MAIN APPLICATION ---

        function App() {
            const [user, setUser] = useState(null);
            const [isLoginOpen, setIsLoginOpen] = useState(false);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [isVocabOpen, setIsVocabOpen] = useState(false);
            const [isReplaceConfirmOpen, setIsReplaceConfirmOpen] = useState(false);

            const [uploadLevel, setUploadLevel] = useState('Level 1');

            // --- NEW: Playback State for Recordings ---
            const [playbackState, setPlaybackState] = useState({ id: null, isPlaying: false });
            const playbackAudioRef = useRef(null);

            const togglePlayback = (url, id) => {
                // 1. If clicking the SAME active recording -> Toggle Pause/Play
                if (playbackState.id === id) {
                    if (playbackState.isPlaying) {
                        playbackAudioRef.current?.pause();
                        setPlaybackState(prev => ({ ...prev, isPlaying: false }));
                    } else {
                        playbackAudioRef.current?.play();
                        setPlaybackState(prev => ({ ...prev, isPlaying: true }));
                    }
                    return;
                }

                // 2. If clicking a DIFFERENT recording -> Stop old, Start new
                if (playbackAudioRef.current) {
                    playbackAudioRef.current.pause();
                    playbackAudioRef.current.currentTime = 0;
                }

                const audio = new Audio(url);
                playbackAudioRef.current = audio;
                
                // Reset state when audio finishes
                audio.onended = () => setPlaybackState({ id: null, isPlaying: false });
                
                audio.play().catch(e => {
                    console.error("Playback failed:", e);
                    alert("Unable to play audio. Format might not be supported on this device.");
                });
                
                setPlaybackState({ id, isPlaying: true });
            };
            
            // --- NEW: Word Lookup State ---
            const [wordPopup, setWordPopup] = useState({ open: false, word: '', data: null, loading: false });

            const handleWordClick = async (clickedWord) => {
                // 1. Clean the word (remove punctuation if any leaked through, though regex mostly handles it)
                const cleanWord = clickedWord.trim();
                if (!cleanWord) return;

                // 2. Play Audio Immediately
                const u = new SpeechSynthesisUtterance(cleanWord);
                u.lang = 'en-US';
                window.speechSynthesis.speak(u);

                // 3. Open Modal with Loading State
                setWordPopup({ open: true, word: cleanWord, data: null, loading: true });

                // 4. Fetch AI Definition in Context
                const contextSentence = transcript[activeIndex]?.text || "";
                const details = await fetchWordDetails(geminiKey, cleanWord, contextSentence);
                
                // 5. Update Modal
                setWordPopup(prev => ({ ...prev, loading: false, data: details }));
            };

            const handleAddWordToVocab = async () => {
                if (!user || !wordPopup.data) return;
                const { error } = await supabase.from('user_vocabulary').insert([{ 
                    user_id: user.id, 
                    word: wordPopup.word, 
                    definition: wordPopup.data.definition, 
                    example: wordPopup.data.example 
                }]);
                if (!error) {
                    fetchVocabulary(user.id); 
                    alert("Saved to vocabulary!");
                } else {
                    alert("Error saving word");
                }
            };

            // --- NEW: Collapsible Sidebar State ---
            const [collapsedLevels, setCollapsedLevels] = useState({}); // Empty = All Expanded by default

            const toggleLevel = (level) => {
                setCollapsedLevels(prev => ({
                    ...prev,
                    [level]: !prev[level]
                }));
            };

            // --- RESPONSIVE STATE ---
        const [isMobile, setIsMobile] = useState(window.innerWidth < 1024);
        const [sidebarOpen, setSidebarOpen] = useState(window.innerWidth >= 1024);
        // Default transcript to CLOSED on mobile, OPEN on large desktops
        const [transcriptOpen, setTranscriptOpen] = useState(window.innerWidth >= 1280);

        useEffect(() => {
            const handleResize = () => {
                const mobile = window.innerWidth < 1024;
                setIsMobile(mobile);
                if (mobile) {
                    // Force close sidebars when resizing down to mobile
                    setSidebarOpen(false);
                    setTranscriptOpen(false); 
                } else {
                    // Force open sidebars when resizing up to desktop
                    setSidebarOpen(true);
                    setTranscriptOpen(window.innerWidth >= 1280);
                }
            };
            window.addEventListener('resize', handleResize);
            return () => window.removeEventListener('resize', handleResize);
        }, []);

            // --- NEW: Keyboard Shortcuts (Space to Play/Pause) ---
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.code === 'Space') {
                        // 1. Check if user is typing in an input box or textarea
                        const tag = document.activeElement.tagName.toLowerCase();
                        const isInput = tag === 'input' || tag === 'textarea' || document.activeElement.isContentEditable;
                        
                        // 2. Only toggle play/pause if NOT typing
                        if (!isInput) {
                            e.preventDefault(); // Prevent page scrolling
                            // Use functional update to get the latest state safely
                            setIsPlaying(prev => !prev);
                            
                            // Optional: Reset "Stop at End" logic if user manually interferes
                            if (stopAtTimeRef.current) stopAtTimeRef.current = null;
                        }
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);

            const [fixPanelOpen, setFixPanelOpen] = useState(false);
            const [fixPanelMode, setFixPanelMode] = useState('ai'); // 'ai' or 'manual'
            const [userRole, setUserRole] = useState(null);
            const [collections, setCollections] = useState([]);
            const [activeCollectionId, setActiveCollectionId] = useState('default'); // 'default' = My Collection
            const [isCollectionModalOpen, setIsCollectionModalOpen] = useState(false);
            const [isShareModalOpen, setIsShareModalOpen] = useState(false);

            const [source, setSource] = useState(null);
            const [transcript, setTranscript] = useState([]);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [seekTrigger, setSeekTrigger] = useState(0);
            const [loopRange, setLoopRange] = useState(null);
            
            // --- FIX: Use useRef for Stop Time to prevent stale closure issues in audio loop ---
            const stopAtTimeRef = useRef(null); 
            
            const [history, setHistory] = useState([]);
            const [vocabulary, setVocabulary] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingError, setProcessingError] = useState(null); 
            const [contextPrompt, setContextPrompt] = useState("");
            const [geminiKey, setGeminiKey] = useState("");
            const [pendingFile, setPendingFile] = useState(null);
            const [activeTab, setActiveTab] = useState('Shadowing');
            const [chunkSize, setChunkSize] = useState('single'); 

            const [dictationValues, setDictationValues] = useState({});
            const [dictationChecked, setDictationChecked] = useState(false);
            const [showDictationContent, setShowDictationContent] = useState(false);
            const [analysis, setAnalysis] = useState(null);
            const [isAnalyzing, setIsAnalyzing] = useState(false);

            const [translationAttempt, setTranslationAttempt] = useState("");
            const [showTranslationAnswer, setShowTranslationAnswer] = useState(false);

            const [isRecording, setIsRecording] = useState(false);
            const [recorder, setRecorder] = useState(null);
            const [recordedBlob, setRecordedBlob] = useState(null);
            const [recordingsList, setRecordingsList] = useState([]);
            const [isSavingRecord, setIsSavingRecord] = useState(false);

            // --- NEW: Persistent Microphone Stream Ref ---
            const streamRef = useRef(null);

            // Cleanup stream on component unmount
            useEffect(() => {
                return () => {
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(track => track.stop());
                    }
                };
            }, []);

            const saveLockRef = useRef(false); // Prevents double-clicking

            // Re-analysis State (AI)
            const [correctionHint, setCorrectionHint] = useState("");
            const [isReAnalyzing, setIsReAnalyzing] = useState(false);
            const [reAnalysisError, setReAnalysisError] = useState(null);
            const [selectedIndices, setSelectedIndices] = useState([]);
            const [lastSelectedIndex, setLastSelectedIndex] = useState(null);
            const [reAnalysisPreview, setReAnalysisPreview] = useState(null);

            // Manual Edit State
            const [editingIndex, setEditingIndex] = useState(null);
            const [manualEndTime, setManualEndTime] = useState("");
            const [shiftFollowing, setShiftFollowing] = useState(false);
            const [isSavingManual, setIsSavingManual] = useState(false);
            const [showShadowingContent, setShowShadowingContent] = useState(false);
            
            // --- NEW: SUMMARY FEATURE STATE ---
            const [visitedIndices, setVisitedIndices] = useState(new Set());

            // 1. Track progress: When audio plays a specific index, mark it as visited
            useEffect(() => {
                if (activeIndex !== -1 && isPlaying) {
                    setVisitedIndices(prev => {
                        const newSet = new Set(prev);
                        newSet.add(activeIndex);
                        return newSet;
                    });
                }
            }, [activeIndex, isPlaying]);

            // 2. Reset progress when loading a new file
            useEffect(() => {
                setVisitedIndices(new Set());
                // Reset other states as well
                setDictationValues({}); 
                setDictationChecked(false); 
                setShowDictationContent(false); 
                setAnalysis(null);
                setCorrectionHint("");
                setTranslationAttempt("");
                setShowTranslationAnswer(false);
            }, [source]);

            const [shareToastVisible, setShareToastVisible] = useState(false);
            const [selectionState, setSelectionState] = useState({ visible: false, x: 0, y: 0, text: '' });

            const activeIndex = transcript.findIndex((s, idx) => {
                const nextStart = transcript[idx + 1]?.start || Infinity;
                return currentTime >= s.start && currentTime < nextStart;
            });

            // --- NEW: Auto-Scroll Sidebar to Active Sentence ---
            useEffect(() => {
                // 1. Check if there is a valid active sentence
                if (activeIndex !== -1) {
                    // 2. Find the HTML element with the specific ID (we will add IDs in Step 2)
                    const el = document.getElementById(`transcript-item-${activeIndex}`);
                    
                    // 3. If the element exists, scroll it smoothly to the center of the view
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }, [activeIndex]); // <--- This dependency array ensures it runs every time activeIndex updates

            const autoCollapseTranscript = () => { if (transcriptOpen) setTranscriptOpen(false); };

            // OPTIMIZED: Intelligent Panel Management for Mobile
            useEffect(() => {
                if (!source) { 
                    // 1. App Entry / No File Loaded
                    // Mobile: Keep Library CLOSED so user sees the "Upload/Welcome" screen immediately.
                    // Desktop: Open Library by default.
                    setSidebarOpen(!isMobile); 
                    setTranscriptOpen(false);
                } else { 
                    // 2. File Loaded (Entering Audio)
                    // Always close Library to focus on content.
                    setSidebarOpen(false); 
                    
                    // Mobile: Keep Transcript CLOSED so user sees the "Practicing Panel" (Player/Tabs).
                    // Desktop: Auto-open Transcript only on large screens (XL).
                    setTranscriptOpen(!isMobile && window.innerWidth >= 1280);
                }
            }, [source, isMobile]);

            useEffect(() => {
                setDictationValues({}); setDictationChecked(false); setShowDictationContent(false); setAnalysis(null);
                setCorrectionHint("");
                setTranslationAttempt("");
                setShowTranslationAnswer(false);
            }, [transcript, seekTrigger]);

            useEffect(() => {
                const init = async () => {
                    try {
                        const { data: userData } = await supabase.auth.getUser();
                        if (userData.user) {
                            setUser(userData.user);
                            fetchUserRole(userData.user.id);
                            fetchCollections(userData.user.id); // <--- Add this
                            fetchSettings(userData.user.id);
                            fetchRecordings(userData.user.id);
                            fetchVocabulary(userData.user.id);
                            fetchHistory();
                        }
                        const urlParams = new URLSearchParams(window.location.search);
                        const shareId = urlParams.get('share');
                        if (shareId) {
                            const { data: sharedData, error: sharedError } = await supabase.from('transcripts').select('*').eq('id', shareId).single();
                            if (sharedData && !sharedError) loadSession(sharedData);
                        }
                    } catch (err) { console.error(err); }
                };
                init();
                const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
                    const cu = session?.user ?? null; 
                    setUser(cu); 
                    if (cu) { 
                        fetchUserRole(cu.id);
                        fetchCollections(cu.id); // <--- Add this
                        fetchSettings(cu.id);
                        fetchRecordings(cu.id); 
                        fetchVocabulary(cu.id); 
                        fetchHistory();
                    } else {
                        setUserRole(null); // <--- NEW: Clear role on logout
                    }
                });
                const handleMouseUp = () => {
                    const sel = window.getSelection();
                    if (!sel || sel.rangeCount === 0) return;
                    const text = sel.toString().trim();
                    if (text && text.length > 0 && text.length < 50) {
                        const range = sel.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        setSelectionState({ visible: true, x: rect.left + (rect.width / 2), y: rect.top + window.scrollY, text: text });
                    } else {
                        setSelectionState(prev => ({ ...prev, visible: false }));
                    }
                };
                document.addEventListener('mouseup', handleMouseUp);
                return () => { 
                    if (subscription) subscription.unsubscribe(); 
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, []);

            // --- NEW: Refresh list when switching folders ---
            useEffect(() => {
                if (user) fetchHistory();
            }, [activeCollectionId, user]);

            const fetchCollections = async (uid) => {
    const { data } = await supabase.from('collections').select('*').order('created_at');
    if (data) setCollections(data);
};

const createCollection = async (name) => {
    if (!user) return;
    const { data, error } = await supabase.from('collections').insert([{ user_id: user.id, name }]).select().single();
    if (data) {
        setCollections([...collections, data]);
        setActiveCollectionId(data.id); // Switch to new folder
    }
};

const shareCollection = async (emailToInvite) => {
                if (activeCollectionId === 'default') {
                    alert("You cannot share your default 'My Collection'. Please create a new folder first.");
                    return;
                }
                
                // 1. Find the user ID securely using the RPC function
                const { data: profileData, error: profileError } = await supabase
                    .rpc('get_user_id_by_email', { email_input: emailToInvite.trim() });

                if (profileError || !profileData) {
                    alert("User not found! Make sure they have signed up for LingoMate first.");
                    return;
                }

                // 2. Add them to the members table
                const { error: memberError } = await supabase
                    .from('collection_members')
                    .insert({ collection_id: activeCollectionId, user_id: profileData.id });

                if (memberError) {
                    if (memberError.code === '23505') alert("This user is already a member!");
                    else alert("Failed to share: " + memberError.message);
                } else {
                    alert(`Successfully shared with ${emailToInvite}`);
                }
            };

            const fetchUserRole = async (uid) => {
                const { data } = await supabase
                    .from('profiles')
                    .select('role')
                    .eq('id', uid)
                    .maybeSingle(); // Use maybeSingle to be safe
                if (data) setUserRole(data.role);
            };

            const fetchSettings = async (uid) => {
                const { data } = await supabase.from('user_settings').select('gemini_api_key').eq('user_id', uid).single();
                if (data?.gemini_api_key) setGeminiKey(data.gemini_api_key);
            };

            const saveSettings = async (nk) => {
                setGeminiKey(nk);
                if (user) await supabase.from('user_settings').upsert({ user_id: user.id, gemini_api_key: nk });
            };

            const fetchHistory = async () => {
                if (!user) return;
                
                // FIX: Do NOT filter by .eq('user_id', user.id) here.
                // We trust the Database Security Rules (RLS) to show us the correct files.
                let query = supabase.from('transcripts').select('*');

                // Filter: If 'default', look for NULL. Otherwise look for the specific folder ID.
                if (activeCollectionId === 'default') {
                    // For "My Collection", we rely on RLS to only show our own files
                    // But we explicitly check for NULL collection_id
                    query = query.is('collection_id', null).eq('user_id', user.id); 
                    // Note: For Default collection, we keep .eq('user_id') to be extra safe 
                    // so we don't accidentally see other people's unfiled items if RLS fails.
                } else {
                    // For Shared Collections, we MUST accept files from other users.
                    query = query.eq('collection_id', activeCollectionId);
                }

                const { data } = await query.order('created_at', { ascending: false });
                if (data) setHistory(data);
            };
            
            const fetchRecordings = async (uid) => {
                const { data } = await supabase.from('user_recordings').select('*').eq('user_id', uid).order('created_at', { ascending: false });
                if (data) setRecordingsList(data);
            };

            const fetchVocabulary = async (uid) => {
                const { data } = await supabase.from('user_vocabulary').select('*').eq('user_id', uid).order('created_at', { ascending: false });
                if (data) setVocabulary(data);
            };

            const saveSelectionToVocab = async () => {
                if (!user) { setIsLoginOpen(true); return; }
                const { error } = await supabase.from('user_vocabulary').insert([{ user_id: user.id, word: selectionState.text, definition: "Added from selection", example: "" }]);
                if (!error) { fetchVocabulary(user.id); setSelectionState(prev => ({ ...prev, visible: false })); }
            };

            const saveVocabWord = async () => {
                if (!analysis || !user) return;
                const { error } = await supabase.from('user_vocabulary').insert([{ user_id: user.id, word: analysis.content, definition: analysis.meaning, example: "" }]);
                if (!error) { fetchVocabulary(user.id); }
            };

            const deleteVocabWord = async (id) => {
                const { error } = await supabase.from('user_vocabulary').delete().eq('id', id);
                if (!error) fetchVocabulary(user.id);
            };

            const handleAuth = async (email, password, mode) => {
                try {
                    if (mode === 'signup') {
                        const { error } = await supabase.auth.signUp({
                            email,
                            password,
                        });
                        if (error) throw error;
                        alert("Signup successful! Please check your email for the confirmation link.");
                        setIsLoginOpen(false);
                    } else {
                        const { error } = await supabase.auth.signInWithPassword({
                            email,
                            password,
                        });
                        if (error) throw error;
                        setIsLoginOpen(false);
                    }
                } catch (error) {
                    console.error("Auth error:", error.message);
                    return error.message;
                }
            };

            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const existing = history.find(h => h.title === file.name);
                if (existing) { setPendingFile(file); setIsReplaceConfirmOpen(true); } 
                else { processFileUpload(file); }
            };

            const processFileUpload = async (file) => {
                const url = URL.createObjectURL(file);
                const duration = await getMediaDuration(file);
                setSource({ type: 'file', mediaType: file.type.startsWith('audio/') ? 'audio' : 'video', url, title: file.name, fileData: file, duration });
                setTranscript([]); setIsPlaying(false);
            };

            const handleGenerate = async () => {
                if (!source) return;
                setIsProcessing(true);
                setProcessingError(null);
                try {
                    // 1. Process Transcription (AI)
                    const result = await processTranscription(geminiKey, source.fileData, contextPrompt || source.title, source.duration || 0);
                    setTranscript(result);
                    
                    if (user) {
                        // 2. SMART CLEANUP: Identify and remove old versions
                        // Helper: Normalizes titles so "123_Solid_Joys" matches "Solid Joys"
                        const getComparisonName = (t) => {
                            // Remove 13-digit timestamp prefix if present
                            const noTimestamp = t.replace(/^\d{13}_/, '');
                            // Sanitize to match file-system naming (underscores, lowercase)
                            return sanitizeFilename(noTimestamp).toLowerCase();
                        };
                        
                        const currentComparisonName = getComparisonName(source.title);

                        // Fetch ALL transcripts to ensure we catch every variation
                        const { data: allUserTranscripts } = await supabase
                            .from('transcripts')
                            .select('id, title, source_url')
                            .eq('user_id', user.id);

                        let targetId = null;

                        if (allUserTranscripts) {
                            // Filter: Find all DB entries that "mean" the same file
                            const duplicates = allUserTranscripts.filter(t => {
                                return getComparisonName(t.title) === currentComparisonName;
                            });

                            if (duplicates.length > 0) {
                                // We will reuse the first ID found, and delete the rest
                                targetId = duplicates[0].id;

                                for (const entry of duplicates) {
                                    // A. Delete the actual audio file from Storage
                                    if (entry.source_url) {
                                        try {
                                            const urlParts = entry.source_url.split('/media/');
                                            if (urlParts.length > 1) {
                                                // Decode to handle spaces/symbols correctly
                                                const oldPath = decodeURIComponent(urlParts[1]);
                                                // Remove any query parameters
                                                const cleanPath = oldPath.split('?')[0]; 
                                                await supabase.storage.from('media').remove([cleanPath]);
                                                console.log("Cleanup: Deleted old media file:", cleanPath);
                                            }
                                        } catch (cleanupErr) {
                                            console.warn("Failed to cleanup storage file:", cleanupErr);
                                        }
                                    }

                                    // B. Delete duplicate Database rows (except the one we reuse)
                                    if (entry.id !== targetId) {
                                        await supabase.from('transcripts').delete().eq('id', entry.id);
                                    }
                                }
                            }
                        }

                        // 3. Upload New File (with unique timestamp to avoid caching)
                        const sanitizedTitle = sanitizeFilename(source.title);
                        const filePath = `${user.id}/${Date.now()}_${sanitizedTitle}`;
                        
                        const { error: uploadError } = await supabase.storage.from('media').upload(filePath, source.fileData, { cacheControl: '3600', upsert: true });
                        if (uploadError) throw uploadError;

                        const { data: urlData } = supabase.storage.from('media').getPublicUrl(filePath);

                        // 4. Update Database
                        // We save the CLEAN title (without timestamp) so the Sidebar looks nice
                        const cleanDisplayTitle = source.title.replace(/^\d{13}_/, '');

                        // ... inside handleGenerate ...
                        
                        const payload = { 
                            user_id: user.id, 
                            collection_id: activeCollectionId === 'default' ? null : activeCollectionId,
                            level: uploadLevel, // <--- ADD THIS (We will define uploadLevel state next)
                            title: cleanDisplayTitle, 
                            source_type: source.mediaType, 
                            source_url: urlData.publicUrl, 
                            content: result 
                        };

                        if (targetId) {
                            // Update the existing record we kept
                            await supabase.from('transcripts').update(payload).eq('id', targetId);
                            setSource(prev => ({...prev, id: targetId, title: cleanDisplayTitle}));
                        } else {
                            // Insert a new record
                            const { data } = await supabase.from('transcripts').insert(payload).select().single();
                            if(data) setSource(prev => ({...prev, id: data.id, title: cleanDisplayTitle}));
                        }
                        
                        fetchHistory();
                    }
                } catch (err) { 
                    console.error(err);
                    setProcessingError(err.message); 
                }
                setIsProcessing(false);
            };

            const handleTimeUpdate = (t) => {
                // 1. Handle "Stop at End of Sentence" logic
                // We check this BEFORE updating state to prevent the UI from flashing the next sentence.
                if (stopAtTimeRef.current !== null && t >= stopAtTimeRef.current) {
                    setIsPlaying(false);
                    
                    // Snap back slightly (0.1s) to ensure the UI stays highlighted on the CURRENT sentence
                    // instead of drifting into the next one.
                    const safeEndTime = Math.max(0, stopAtTimeRef.current - 0.1);
                    setCurrentTime(safeEndTime); 
                    
                    // Force the audio player to sync to this new time
                    setSeekTrigger(prev => prev + 1); 
                    
                    stopAtTimeRef.current = null;
                    return; // Exit early
                }

                // 2. Normal Time Update
                setCurrentTime(t);
                
                // 3. Loop Logic (Existing)
                if (loopRange && isPlaying && t >= loopRange.end) {
                    setCurrentTime(loopRange.start); // Ensure we actually loop back to start
                    setSeekTrigger(prev => prev + 1);
                }
            };

            const handleReAnalyze = async () => {
                if (!source) return;
                setReAnalysisError(null);
                let fileBlob = source.fileData;
                if (!fileBlob && source.url) {
                    try {
                        const urlParts = source.url.split('/public/media/');
                        if (urlParts.length > 1) {
                            const storagePath = decodeURIComponent(urlParts[1]);
                            const { data, error } = await supabase.storage.from('media').download(storagePath);
                            if (error) throw error;
                            fileBlob = data;
                        } else {
                            const res = await fetch(source.url);
                            if (!res.ok) throw new Error("Fetch failed");
                            fileBlob = await res.blob();
                        }
                    } catch (err) { setReAnalysisError("Could not retrieve media file."); return; }
                }
                if (!fileBlob) return;

                const indicesToFix = selectedIndices.length > 0 ? [...selectedIndices].sort((a, b) => a - b) : (activeIndex !== -1 ? [activeIndex] : []);
                if (indicesToFix.length === 0) return;

                const startIdx = indicesToFix[0];
                const endIdx = indicesToFix[indicesToFix.length - 1];
                const startTime = transcript[startIdx].start;
                const endTime = transcript[endIdx].end;

                setIsReAnalyzing(true);
                try {
                    const newSegments = await fetchBatchReAnalysis(geminiKey, fileBlob, startTime, endTime, correctionHint);
                    if (!Array.isArray(newSegments)) throw new Error("Invalid format");
                    setReAnalysisPreview({ startIdx, endIdx, segments: newSegments });
                } catch (err) { setReAnalysisError("Re-analysis failed: " + err.message); } finally { setIsReAnalyzing(false); }
            };

            const confirmReAnalysis = async () => {
                if (!reAnalysisPreview) return;
                const { startIdx, endIdx, segments } = reAnalysisPreview;
                const newTranscript = [...transcript];
                newTranscript.splice(startIdx, (endIdx - startIdx + 1), ...segments);
                setTranscript(newTranscript);
                if (user && source.id) { await supabase.from('transcripts').update({ content: newTranscript }).eq('id', source.id); fetchHistory(); }
                setReAnalysisPreview(null); setCorrectionHint(""); setSelectedIndices([]); setLastSelectedIndex(null); setFixPanelOpen(false);
            };

            // --- FIXED MANUAL EDIT LOGIC ---
            const handleManualEditOpen = (e, index) => {
                e.stopPropagation();
                setEditingIndex(index);
                setManualEndTime(transcript[index].end.toString());
                setFixPanelMode('manual');
                setFixPanelOpen(true);
                setIsPlaying(false);
                setCurrentTime(transcript[index].start);
                setSeekTrigger(prev => prev + 1);
            };

           const confirmManualEdit = async () => {
                if (editingIndex === null) return;
                setIsSavingManual(true);

                try {
                    // 1. Calculate the new transcript locally
                    const newTranscript = JSON.parse(JSON.stringify(transcript));
                    const newEndVal = parseFloat(manualEndTime);
                    
                    if (isNaN(newEndVal)) {
                        alert("Invalid Time format");
                        setIsSavingManual(false);
                        return;
                    }

                    const currentStart = newTranscript[editingIndex].start;
                    
                    // Update current item's end
                    if (newEndVal <= currentStart) {
                         newTranscript[editingIndex].end = currentStart + 0.1;
                    } else {
                         newTranscript[editingIndex].end = newEndVal;
                    }

                    // Shift logic (if enabled)
                    if (shiftFollowing) {
                        let runningStart = newTranscript[editingIndex].end;
                        for (let i = editingIndex + 1; i < newTranscript.length; i++) {
                            const originalDuration = transcript[i].end - transcript[i].start;
                            const safeDuration = Math.max(0.1, originalDuration);
                            newTranscript[i].start = runningStart;
                            newTranscript[i].end = runningStart + safeDuration;
                            runningStart = newTranscript[i].end;
                        }
                    } else {
                        // Standard link logic
                        if (editingIndex + 1 < newTranscript.length) {
                             newTranscript[editingIndex + 1].start = newTranscript[editingIndex].end;
                             if (newTranscript[editingIndex + 1].end <= newTranscript[editingIndex + 1].start) {
                                  newTranscript[editingIndex + 1].end = newTranscript[editingIndex + 1].start + 0.1;
                             }
                        }
                    }

                    // 2. Update the Screen (Optimistic UI)
                    setTranscript(newTranscript);
                    
                    // 3. Update the Database (Supabase)
                    if (user) {
                        if (!source.id) {
                            console.warn("No Source ID found. Attempting to match by title...");
                            const { data: foundData } = await supabase
                                .from('transcripts')
                                .select('id')
                                .eq('user_id', user.id)
                                .eq('title', source.title)
                                .maybeSingle(); 

                            if (foundData) {
                                source.id = foundData.id;
                            } else {
                                alert("Warning: This transcript is not saved in your library yet. Please regenerate it while logged in to save changes permanently.");
                                setIsSavingManual(false);
                                return;
                            }
                        }

                        // --- FIX IS HERE: We removed .single() ---
                        const { data, error } = await supabase
                            .from('transcripts')
                            .update({ content: newTranscript })
                            .eq('id', source.id)
                            .select(); 

                        if (error) {
                            console.error("Supabase Error:", error);
                            alert("Failed to save to cloud: " + error.message);
                        } else if (data && data.length === 0) {
                            // Now we catch the specific error safely
                            alert("Update failed: The database record was not found. You might not have permission to edit this file, or it was deleted.");
                        } else {
                            console.log("Saved successfully to Supabase!");
                            fetchHistory(); 
                        }
                    } else {
                        console.log("User not logged in, changes are local only.");
                    }
                    
                    setFixPanelOpen(false);
                    setEditingIndex(null);
                } catch (e) {
                    console.error("Save logic failed", e);
                    alert("An error occurred while saving: " + e.message);
                } finally {
                    setIsSavingManual(false);
                }
            };

            const playManualRange = () => {
                if (editingIndex === null) return;
                const start = transcript[editingIndex].start;
                const endVal = parseFloat(manualEndTime) || (start + 1);
                setCurrentTime(start);
                setSeekTrigger(prev => prev + 1);
                setIsPlaying(true);
                stopAtTimeRef.current = endVal; // FIX: Update Ref
            };

            const handleShare = (item) => {
                const shareLink = `${window.location.origin}${window.location.pathname}?share=${item.id}`;
                navigator.clipboard.writeText(shareLink).then(() => {
                    setShareToastVisible(true);
                    setTimeout(() => setShareToastVisible(false), 3000);
                });
            };

            const handleDeleteSession = async (e, item) => {
                e.stopPropagation();
                if (!confirm(`Are you sure you want to delete "${item.title}"?`)) return;

                // 1. Delete the actual audio file from Storage
                if (item.source_url) {
                    try {
                        // Extract the path after '/media/'
                        const urlParts = item.source_url.split('/media/');
                        if (urlParts.length > 1) {
                            // Decode to handle spaces/symbols and remove query params
                            const storagePath = decodeURIComponent(urlParts[1]).split('?')[0];
                            
                            const { error: storageError } = await supabase.storage.from('media').remove([storagePath]);
                            if (storageError) {
                                console.warn("Storage file not found or already deleted:", storageError);
                            } else {
                                console.log("Successfully deleted storage file:", storagePath);
                            }
                        }
                    } catch (err) {
                        console.error("Error parsing storage URL during delete:", err);
                    }
                }

                // 2. Delete the Database Record
                const { error } = await supabase.from('transcripts').delete().eq('id', item.id);

                if (error) {
                    alert("Failed to delete session: " + error.message);
                } else {
                    // 3. Update UI
                    fetchHistory();
                    // If the user deleted the currently playing file, close the player
                    if (source && source.id === item.id) {
                        setSource(null);
                    }
                }
            };

            const handleTranscriptSeek = (index) => {
                // 1. Safety Checks
                if (!transcript || transcript.length === 0) return;
                if (index < 0 || index >= transcript.length) return;

                const startSeg = transcript[index];
                
                // 2. Determine Target Duration based on Dropdown
                let minDuration = 0;
                switch (chunkSize) {
                    case '5-8': minDuration = 5; break;
                    case '15-18': minDuration = 15; break;
                    case '30-35': minDuration = 30; break;
                    case '60-65': minDuration = 60; break;
                    default: minDuration = 0; // 'single' means stop immediately
                }

                // 3. Calculate End Point
                // We loop forward from the current sentence adding up time until we hit the target.
                let endIndex = index;
                for (let i = index; i < transcript.length; i++) {
                    const currentSeg = transcript[i];
                    const currentDuration = currentSeg.end - startSeg.start;
                    
                    endIndex = i; // This sentence is part of the chunk
                    
                    // If we have played enough seconds, stop adding sentences
                    if (currentDuration >= minDuration) break;
                }

                const endSeg = transcript[endIndex];

                // 4. Start Playback
                setSeekTrigger(prev => prev + 1); 
                setCurrentTime(startSeg.start); 
                setIsPlaying(true); 
                
                // CRITICAL FIX: Stop at the end of the *calculated chunk*, not just the current sentence
                stopAtTimeRef.current = endSeg.end; 
                
                // 5. Update Progress (Mark ALL sentences in this chunk as 'visited')
                setVisitedIndices(prev => {
                    const newSet = new Set(prev);
                    for (let i = index; i <= endIndex; i++) {
                        newSet.add(i);
                    }
                    return newSet;
                });
            };

            const handleSidebarClick = (e, idx) => {
                let newSelected = [...selectedIndices];
                if (e.shiftKey && lastSelectedIndex !== null) {
                    const start = Math.min(lastSelectedIndex, idx);
                    const end = Math.max(lastSelectedIndex, idx);
                    const range = Array.from({ length: end - start + 1 }, (_, i) => start + i);
                    setSelectedIndices(range);
                } else if (e.ctrlKey || e.metaKey) {
                    if (newSelected.includes(idx)) {
                        newSelected = newSelected.filter(i => i !== idx);
                    } else {
                        newSelected.push(idx);
                    }
                    setSelectedIndices(newSelected);
                    setLastSelectedIndex(idx);
                } else {
                    setSelectedIndices([idx]);
                    setLastSelectedIndex(idx);
                    handleTranscriptSeek(idx);
                }
            };

            const selectAllAfter = (idx) => {
                const range = Array.from({ length: transcript.length - idx }, (_, i) => idx + i);
                setSelectedIndices(range);
                setFixPanelMode('ai');
                setFixPanelOpen(true);
            };

            const triggerAnalysis = async () => {
                autoCollapseTranscript();
                const sentence = transcript[activeIndex]?.text;
                if (!sentence) return;
                setIsAnalyzing(true);
                try {
                    const res = await fetchMeaningAndGrammar(geminiKey, sentence);
                    setAnalysis({ ...res, content: sentence });
                    setIsAnalyzing(false);
                    if (activeTab === 'Shadowing') setActiveTab('Meaning and Grammar');
                } catch (err) { console.error(err); setIsAnalyzing(false); }
            };

            const startRecording = async () => {
                try {
                    let stream = streamRef.current;
                    // Check if we have an active stream, if not, request it once
                    if (!stream || !stream.active || stream.getTracks().some(t => t.readyState === 'ended')) {
                        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        streamRef.current = stream;
                    }

                    // FIX: Detect supported MIME type for Mobile (iOS/Android) compatibility
                    let options = undefined;
                    if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        options = { mimeType: 'audio/mp4' };
                    } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                        options = { mimeType: 'audio/webm' };
                    }

                    const newRecorder = new MediaRecorder(stream, options);
                    const chunks = [];
                    newRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) chunks.push(e.data);
                    };

                    newRecorder.onstop = () => {
                        // CRITICAL: Use the recorder's actual mimeType
                        const type = newRecorder.mimeType || 'audio/webm';
                        setRecordedBlob(new Blob(chunks, { type }));
                    };
                    
                    newRecorder.start();
                    setRecorder(newRecorder);
                    setIsRecording(true);
                } catch (e) { 
                    console.error(e);
                    alert("Could not access microphone. Please check permissions.");
                }
            };

        const stopRecording = () => {
            if (recorder) {
                recorder.stop();
                // NOTE: We do NOT stop the stream tracks here anymore. 
                // This keeps the permission 'alive' for the next recording.
                setIsRecording(false);
            }
        };

            const saveRecording = async () => {
                if (!recordedBlob) return;
                
                // 1. INSTANT LOCK: Prevent double-clicks immediately
                if (saveLockRef.current) return; 
                saveLockRef.current = true;
                
                // 2. Check Login
                if (!user) {
                    alert("Please sign in to save your recordings.");
                    saveLockRef.current = false; 
                    return;
                }
                
                setIsSavingRecord(true);

                try {
                    const isShadowing = activeTab === 'Shadowing' && source;
                    // Create a "Base Name" that identifies this sentence
                    // We will search for anything starting with this string later
                    const shadowingBaseName = isShadowing 
                        ? `Shadowing - ${source.title} - S${activeIndex} -` 
                        : null;

                    let title = `Recording ${new Date().toLocaleString()}`;
                    if (isShadowing) {
                        // We append the timestamp here, making the full title unique
                        title = `${shadowingBaseName}${Date.now()}`;
                    }

                    // 3. Upload New File to Storage (This creates a new unique file)
                    const path = `${user.id}/recordings/${Date.now()}.webm`;
                    const { error: uploadError } = await supabase.storage.from('media').upload(path, recordedBlob);
                    if (uploadError) throw new Error("Upload failed: " + uploadError.message);
                    
                    // 4. Insert New Record into Database
                    const { data: urlData } = supabase.storage.from('media').getPublicUrl(path);
                    
                    // NOTE: We select().single() to get back the ID of the record we just created
                    const { data: newRecord, error: dbError } = await supabase.from('user_recordings').insert([{ 
                        user_id: user.id, 
                        title: title, 
                        file_url: urlData.publicUrl 
                    }]).select().single();
                    
                    if (dbError) throw new Error("Database save failed: " + dbError.message);

                    // 5. CLEANUP: Find and Delete OLD records for this sentence
                    if (isShadowing && newRecord) {
                        // Find ALL records that start with "Shadowing - Title - S[x] -"
                        const { data: duplicates } = await supabase
                            .from('user_recordings')
                            .select('id, file_url')
                            .eq('user_id', user.id)
                            .ilike('title', `${shadowingBaseName}%`); // Search by Prefix

                        if (duplicates && duplicates.length > 0) {
                            // Filter list: Keep the NEW record, delete everything else
                            const idsToDelete = duplicates
                                .filter(r => r.id !== newRecord.id) // Exclude the one we just made
                                .map(r => r.id);

                            if (idsToDelete.length > 0) {
                                // A. Delete from Database
                                await supabase.from('user_recordings').delete().in('id', idsToDelete);
                                console.log("Cleaned up old versions:", idsToDelete);

                                // B. (Optional) Delete from Storage to save space
                                // We extract the path from the public URL to delete the actual file
                                const pathsToDelete = duplicates
                                    .filter(r => r.id !== newRecord.id)
                                    .map(r => {
                                        const urlParts = r.file_url.split('/media/');
                                        return urlParts.length > 1 ? urlParts[1] : null;
                                    })
                                    .filter(p => p !== null);
                                
                                if (pathsToDelete.length > 0) {
                                    await supabase.storage.from('media').remove(pathsToDelete);
                                }
                            }
                        }
                    }

                    // 6. Refresh List
                    await fetchRecordings(user.id);
                    setRecordedBlob(null);

                } catch (err) {
                    console.error(err);
                    alert("Error saving recording: " + err.message);
                } finally {
                    setIsSavingRecord(false);
                    saveLockRef.current = false; // Release lock
                }
            };

            const loadSession = (item) => { 
                let content = item.content || [];
                if (typeof content === 'string') {
                    try { content = JSON.parse(content); } catch (e) { content = []; }
                }
                setTranscript(Array.isArray(content) ? content : []); 
                setSource({ id: item.id, type: 'file', mediaType: item.source_type, url: item.source_url, title: item.title, fileData: null }); 
                setIsPlaying(false); 
            };

            return (
                <div className="h-full flex flex-col font-sans text-gray-900 bg-white fade-in overflow-hidden relative">
                    <CreateCollectionModal isOpen={isCollectionModalOpen} onClose={() => setIsCollectionModalOpen(false)} onCreate={createCollection} />
                    <ShareCollectionModal isOpen={isShareModalOpen} onClose={() => setIsShareModalOpen(false)} onShare={shareCollection} />
                    <LoginModal isOpen={isLoginOpen} onClose={() => setIsLoginOpen(false)} onLogin={handleAuth} />
                    <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} apiKey={geminiKey} onSave={saveSettings} />
                    <VocabularyModal isOpen={isVocabOpen} onClose={() => setIsVocabOpen(false)} words={vocabulary} onDelete={deleteVocabWord} />
                    <ConfirmModal isOpen={isReplaceConfirmOpen} title="Replace Session?" message="A session already exists for this file. Would you like to replace it?" onConfirm={() => { if (pendingFile) processFileUpload(pendingFile); setIsReplaceConfirmOpen(false); }} onCancel={() => setIsReplaceConfirmOpen(false)} />

                    {shareToastVisible && (
                        <div className="share-toast px-6 py-3 bg-emerald-600 text-white rounded-full shadow-2xl font-bold flex items-center gap-2">
                            <Check size={18} /> Link copied to clipboard!
                        </div>
                    )}

                    {/* EDIT TOOLS PANEL (LEFT) */}
                    <div className={`fixed inset-y-0 left-0 z-40 w-80 bg-white border-r shadow-2xl transition-transform duration-300 ease-in-out transform ${fixPanelOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                        <div className="h-full flex flex-col">
                            <div className={`p-4 border-b flex justify-between items-center ${fixPanelMode === 'ai' ? 'bg-red-50' : 'bg-indigo-50'}`}>
                                <div className={`flex items-center gap-2 font-bold ${fixPanelMode === 'ai' ? 'text-red-900' : 'text-indigo-900'}`}>
                                    {fixPanelMode === 'ai' ? <><Wand2 size={18} /> AI Fix</> : <><Pencil size={18} /> Manual Edit</>}
                                </div>
                                <button onClick={() => { setFixPanelOpen(false); setReAnalysisPreview(null); setEditingIndex(null); }} className="p-1 hover:bg-white/50 rounded-full"><X size={20} /></button>
                            </div>
                            
                            <div className="flex-1 p-6 space-y-6 overflow-y-auto custom-scrollbar">
                                {fixPanelMode === 'ai' && (
                                    !reAnalysisPreview ? (
                                        <div className="space-y-4">
                                            <h4 className="text-sm font-bold text-gray-600">{selectedIndices.length > 0 ? `${selectedIndices.length} segments selected` : 'No segments selected'}</h4>
                                            <textarea placeholder="Enter correction hints here..." className="w-full p-4 bg-gray-50 border border-gray-200 rounded-2xl text-sm outline-none focus:ring-2 focus:ring-red-500 min-h-[150px]" value={correctionHint} onChange={(e) => setCorrectionHint(e.target.value)} />
                                            {reAnalysisError && <div className="p-3 bg-red-50 text-red-600 text-[10px] rounded-xl font-medium border border-red-100">{reAnalysisError}</div>}
                                            <button onClick={handleReAnalyze} disabled={isReAnalyzing || (selectedIndices.length === 0 && activeIndex === -1)} className="w-full py-4 bg-red-600 text-white font-bold rounded-2xl flex items-center justify-center gap-2 hover:bg-red-700 transition-all disabled:opacity-50">{isReAnalyzing ? <Spinner /> : <><Wand2 size={16} /> Re-analyze</>}</button>
                                        </div>
                                    ) : (
                                        <div className="space-y-4">
                                            <h4 className="text-sm font-bold text-gray-600">Review Changes</h4>
                                            <div className="space-y-2 max-h-[300px] overflow-y-auto pr-1">
                                                {reAnalysisPreview.segments.map((seg, i) => (
                                                    <div key={i} className="p-2 bg-emerald-50 rounded-lg border border-emerald-100 text-[10px]">
                                                        <div className="font-bold mb-1">{formatTime(seg.start)} - {formatTime(seg.end)}</div>
                                                        <div>{seg.text}</div>
                                                    </div>
                                                ))}
                                            </div>
                                            <div className="flex gap-2 pt-4">
                                                <button onClick={() => setReAnalysisPreview(null)} className="flex-1 py-3 bg-gray-100 text-gray-600 font-bold rounded-xl text-xs">Back</button>
                                                <button onClick={confirmReAnalysis} className="flex-1 py-3 bg-emerald-600 text-white font-bold rounded-xl text-xs shadow-md">Confirm</button>
                                            </div>
                                        </div>
                                    )
                                )}

                                {fixPanelMode === 'manual' && editingIndex !== null && (
                                    <div className="space-y-6 fade-in">
                                        <div className="p-4 bg-gray-50 border border-gray-100 rounded-2xl">
                                            <span className="text-[10px] font-bold text-gray-400 uppercase">Text</span>
                                            <p className="text-sm font-medium mt-1">{transcript[editingIndex].text}</p>
                                        </div>
                                        
                                        <div className="space-y-2">
                                            <label className="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><Clock size={12}/> Start Time</label>
                                            <div className="w-full px-4 py-3 bg-gray-100 border-none rounded-xl text-lg font-mono text-gray-500 flex justify-between items-center">
                                                {formatTime(transcript[editingIndex].start)}
                                                <span className="text-[10px] text-gray-400">Fixed to Prev</span>
                                            </div>
                                        </div>

                                        <div className="space-y-2">
                                            <label className="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><Clock size={12}/> End Time (Sec)</label>
                                            <div className="flex items-center gap-2">
                                                <button onClick={() => setManualEndTime(p => (parseFloat(p) - 0.1).toFixed(3))} className="p-3 bg-gray-100 hover:bg-gray-200 rounded-xl font-bold">-</button>
                                                <input 
                                                    type="number" 
                                                    step="0.01" 
                                                    className="flex-1 px-4 py-3 bg-white border border-indigo-100 focus:border-indigo-500 rounded-xl text-lg font-mono text-center font-bold outline-none shadow-sm" 
                                                    value={manualEndTime} 
                                                    onChange={(e) => setManualEndTime(e.target.value)} 
                                                />
                                                <button onClick={() => setManualEndTime(p => (parseFloat(p) + 0.1).toFixed(3))} className="p-3 bg-gray-100 hover:bg-gray-200 rounded-xl font-bold">+</button>
                                            </div>
                                            <p className="text-center text-xs font-mono text-indigo-600">{formatTime(parseFloat(manualEndTime) || 0)}</p>
                                        </div>

                                        <div className="flex items-center gap-3 p-3 bg-yellow-50 rounded-xl border border-yellow-100">
                                            <input type="checkbox" id="shiftFollow" checked={shiftFollowing} onChange={e => setShiftFollowing(e.target.checked)} className="w-4 h-4 text-indigo-600 rounded" />
                                            <label htmlFor="shiftFollow" className="text-xs font-bold text-yellow-800 cursor-pointer select-none">Shift all following timestamps?</label>
                                        </div>

                                        <button onClick={playManualRange} className="w-full py-3 bg-indigo-50 text-indigo-600 font-bold rounded-xl flex items-center justify-center gap-2 hover:bg-indigo-100 transition-all text-xs border border-indigo-100"><Play size={14} /> Test Selection (Start to New End)</button>

                                        <div className="pt-4 border-t border-gray-100 flex gap-3">
                                            <button onClick={() => setFixPanelOpen(false)} className="flex-1 py-3 bg-white border border-gray-200 text-gray-600 font-bold rounded-xl hover:bg-gray-50 text-xs">Cancel</button>
                                            <button onClick={confirmManualEdit} disabled={isSavingManual} className="flex-1 py-3 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 shadow-lg text-xs flex items-center justify-center gap-2">
                                                {isSavingManual ? <Spinner /> : "Save & Update"}
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    <header className="bg-white border-b border-gray-200 px-4 md:px-6 py-3 md:py-4 flex justify-between items-center z-20 shadow-none sticky top-0">
                        <div className="flex items-center gap-3">
                            <div className="bg-black p-2 rounded-lg">
                                <Volume2 className="text-white w-5 h-5" />
                            </div>
                            <h1 className="text-lg md:text-xl font-bold text-black tracking-tight">
                                LingoMate 
                                <span className="hidden md:inline-block text-xs text-white bg-black px-1.5 ml-1 rounded-md italic font-normal">Listening Practice</span>
                            </h1>
                        </div>
                        <div className="flex items-center gap-2">
                            <button onClick={() => setIsVocabOpen(true)} className="flex items-center gap-2 px-3 md:px-4 py-2 hover:bg-gray-50 rounded-full transition-colors font-semibold text-sm text-gray-600">
                                <BookOpen className="w-5 h-5 md:w-4 md:h-4" /> 
                                <span className="hidden md:inline">Vocabulary</span>
                            </button>
                            <button onClick={() => setIsSettingsOpen(true)} className={`p-2 transition-all ${!geminiKey ? 'text-red-500 animate-pulse' : 'text-gray-400'}`}>
                                <Settings className="w-5 h-5" />
                            </button>
                            {user ? (
                                <div className="flex items-center gap-3 border border-gray-200 pl-3 pr-2 py-1.5 rounded-full font-medium text-sm text-gray-600">
                                    <span className="hidden md:inline">{user.email?.split('@')[0]}</span>
                                    <button onClick={() => { supabase.auth.signOut(); setUser(null); }} className="p-1 bg-gray-100 rounded-full hover:bg-black hover:text-white transition-colors">
                                        <LogOut className="w-4 h-4" />
                                    </button>
                                </div>
                            ) : (
                                <button onClick={() => setIsLoginOpen(true)} className="px-4 md:px-5 py-2 bg-black text-white font-bold text-sm rounded-full transition-colors">
                                    Sign in
                                </button>
                            )}
                        </div>
                    </header>

                    <div className="flex-1 flex overflow-hidden relative group-hover:cursor-auto">
                        {/* Mobile Overlay for Library */}
                    {isMobile && sidebarOpen && (
                        <div onClick={() => setSidebarOpen(false)} className="fixed inset-0 bg-black/50 z-30 backdrop-blur-sm transition-opacity fade-in" />
                    )}
                    <aside className={`
                        ${sidebarOpen ? 'translate-x-0' : '-translate-x-full lg:translate-x-0 lg:w-0 lg:border-none'} 
                        ${isMobile ? 'fixed inset-y-0 left-0 z-40 w-80 shadow-2xl' : 'relative transition-all duration-300 ease-in-out border-r'}
                        ${!isMobile && sidebarOpen ? 'w-80' : ''}
                        bg-white flex flex-col overflow-hidden h-full
                    `}>
                            <div className="p-4 border-b bg-gray-50 space-y-3 min-w-[320px]">
                                <div className="flex justify-between items-center">
                                    <h2 className="font-bold text-sm text-gray-600 flex items-center gap-2">
                                        <Layers className="w-4 h-4" /> Library
                                    </h2>
                                    <button onClick={() => setSidebarOpen(false)} className="p-1.5 hover:bg-gray-200 rounded-lg text-gray-400 transition-colors">
                                        <ChevronLeft className="w-4 h-4" />
                                    </button>
                                </div>

                                {/* Collection Selector */}
                                <div className="flex gap-2">
                                    <select 
                                        value={activeCollectionId} 
                                        onChange={(e) => setActiveCollectionId(e.target.value)} 
                                        className="flex-1 bg-white border border-gray-200 text-xs font-bold rounded-xl px-3 py-2 outline-none focus:border-black cursor-pointer"
                                    >
                                        <option value="default">My Collection (Default)</option>
                                        {collections.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                    </select>
                                    <button onClick={() => setIsCollectionModalOpen(true)} className="p-2 bg-black text-white rounded-xl hover:bg-gray-800 transition-colors" title="New Collection">
                                        <Plus className="w-4 h-4" />
                                    </button>

                                    {/* --- NEW SHARE BUTTON --- */}
                                    {activeCollectionId !== 'default' && (
                                        <button onClick={() => setIsShareModalOpen(true)} className="p-2 bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 transition-colors" title="Share Folder">
                                            <Share2 className="w-4 h-4" />
                                        </button>
                                    )}
                                </div>
                            </div>
                            {/* NEW: Sidebar Grouped by Levels */}
                            <div className="flex-1 overflow-y-auto p-3 min-w-[320px] custom-scrollbar pb-20 space-y-6">
                                {history.length === 0 && <div className="text-center p-8 opacity-20"><Database className="w-8 h-8 mx-auto mb-2" /><p className="text-xs font-semibold">No files saved</p></div>}
                                
                                {['Level 1', 'Level 2', 'Level 3', 'Level 4'].map(level => {
                                    const levelFiles = history.filter(h => (h.level || 'Level 1') === level);
                                    if (levelFiles.length === 0) return null;

                                    // Check if this level is currently collapsed (default is false/undefined)
                                    const isCollapsed = collapsedLevels[level];

                                    return (
                                        <div key={level} className="fade-in mb-2">
                                            {/* Clickable Toggle Header */}
                                            <button 
                                                onClick={() => toggleLevel(level)}
                                                className="w-full px-2 py-1 text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center justify-between hover:text-gray-600 hover:bg-gray-50 rounded-lg transition-all border-b border-gray-100 mb-2 mx-1"
                                            >
                                                <span className="flex items-center gap-2">
                                                    <Layers size={10} /> {level}
                                                </span>
                                                {/* Rotate Icon based on state */}
                                                {isCollapsed ? <ChevronRight size={12} /> : <ChevronDown size={12} />}
                                            </button>
                                            
                                            {/* Collapsible File List */}
                                            {!isCollapsed && (
                                                <div className="space-y-2 animate-in fade-in slide-in-from-top-1 duration-200">
                                                    {levelFiles.map(item => (
                                                        <div key={item.id} onClick={() => loadSession(item)} className={`p-3 border rounded-xl cursor-pointer group relative transition-all shadow-sm hover:shadow-md ${source?.id === item.id ? 'bg-black text-white border-black' : 'bg-white border-gray-100 hover:border-black text-gray-800'}`}>
                                                            <h3 className="font-bold text-xs truncate pr-12">{item.title}</h3>
                                                            <div className={`flex justify-between items-center mt-2 text-[10px] font-medium ${source?.id === item.id ? 'opacity-70' : 'opacity-50'}`}>
                                                                <span>{item.source_type}</span>
                                                                <span>{new Date(item.created_at).toLocaleDateString()}</span>
                                                            </div>
                                                            <div className="absolute top-2.5 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                                                <button onClick={(e) => { e.stopPropagation(); handleShare(item); }} title="Share" className={`p-1 transition-colors ${source?.id === item.id ? 'text-gray-300 hover:text-white' : 'text-gray-400 hover:text-black'}`}><Share2 size={14} /></button>
                                                                <button onClick={(e) => handleDeleteSession(e, item)} title="Delete" className={`p-1 transition-colors ${source?.id === item.id ? 'text-gray-300 hover:text-red-400' : 'text-gray-400 hover:text-red-500'}`}><Trash2 size={14} /></button>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </aside>

                        <main className="flex-1 flex flex-col min-w-0 bg-gray-50 overflow-hidden relative">
                            {/* Toggle Button: Library */}
                            {(!sidebarOpen || isMobile) && (
                                <div className="absolute top-4 left-4 z-20">
                                    <button onClick={() => setSidebarOpen(true)} className="p-3 bg-white/90 backdrop-blur border border-gray-200 rounded-full text-gray-600 shadow-lg hover:bg-gray-50 flex items-center gap-2 px-4 font-bold text-xs uppercase tracking-widest transition-transform hover:scale-105 active:scale-95">
                                        <History className="w-4 h-4" /> <span className="hidden sm:inline">Library</span>
                                    </button>
                                </div>
                            )}
                            
                            {/* Toggle Button: Transcript */}
                            {(!transcriptOpen || isMobile) && transcript.length > 0 && (
                                <div className="absolute top-4 right-4 z-20">
                                    <button onClick={() => setTranscriptOpen(true)} className="p-3 bg-white/90 backdrop-blur border border-gray-200 rounded-full text-gray-600 shadow-lg hover:bg-gray-50 flex items-center gap-2 px-4 font-bold text-xs uppercase tracking-widest transition-transform hover:scale-105 active:scale-95">
                                        {/* Changed: Always show text 'Show Transcript' on mobile */}
                                    <span>Show Transcript</span> <FileText className="w-4 h-4" />
                                    </button>
                                </div>
                            )}

                            <div className="flex-1 flex flex-col overflow-y-auto relative custom-scrollbar">
                                <div className={`px-4 md:px-8 pb-24 pt-20 mx-auto w-full transition-all duration-300 ${activeTab === 'Dictation' ? 'max-w-5xl' : 'max-w-3xl'}`}>
                                    {!source ? (
                                        // LOGIC: If user is logged in AND is a student, show "Student Workspace"
                                        user && userRole === 'student' ? (
                                            <div className="mt-16 bg-white p-12 border border-gray-100 shadow-sm rounded-3xl text-center">
                                                <div className="w-16 h-16 bg-gray-50 mx-auto mb-6 flex items-center justify-center rounded-2xl text-gray-400">
                                                    <BookOpen className="w-8 h-8" />
                                                </div>
                                                <h3 className="font-bold text-2xl mb-2 text-gray-900">Student Workspace</h3>
                                                <p className="text-gray-500 text-sm mb-8 font-normal">
                                                    Please select a lesson from your Library sidebar to begin practice.
                                                </p>
                                            </div>
                                        ) : (
                                            // LOGIC: Otherwise (Teacher or Guest), show the Upload Button
                                            <div className="mt-16 bg-white p-12 border border-gray-100 shadow-sm rounded-3xl text-center group">
                                                <div className="w-16 h-16 bg-gray-50 mx-auto mb-6 flex items-center justify-center group-hover:bg-black rounded-2xl"><Upload className="w-8 h-8" /></div>
                                                <h3 className="font-bold text-2xl mb-2 text-gray-900">Analyze media</h3>
                                                <p className="text-gray-500 text-sm mb-8 font-normal">Upload an audio or video file to start practice.</p>
                                                <label className="block w-full bg-black text-white py-4 font-bold rounded-2xl cursor-pointer hover:bg-gray-800 shadow-lg">Select file<input type="file" className="hidden" accept="video/*,audio/*" onChange={handleFileUpload} /></label>
                                            </div>
                                        )
                                    ) : transcript.length === 0 ? (
                                        <div className="mt-16 bg-white p-10 flex flex-col items-center text-center rounded-3xl shadow-sm border border-gray-100">
                                            <div className="w-12 h-12 bg-gray-50 flex items-center justify-center rounded-xl mb-4 text-gray-400"><FileText className="w-6 h-6" /></div>
                                            <h3 className="font-bold text-lg text-gray-900 mb-2">Generate transcript</h3>
                                            <p className="text-sm text-gray-500 mb-8 max-w-xs leading-relaxed">Generate a sentence-by-sentence transcript to start practicing.</p>
                                            <div className="w-full space-y-4">
                                                {/* NEW: Level Selector & Context Input Row */}
                                                <div className="flex gap-2">
                                                    {/* Level Dropdown */}
                                                    <select 
                                                        value={uploadLevel} 
                                                        onChange={(e) => setUploadLevel(e.target.value)}
                                                        className="bg-gray-50 border-none rounded-2xl px-4 py-3.5 text-sm font-bold outline-none focus:ring-2 focus:ring-black cursor-pointer text-gray-700 min-w-[100px]"
                                                    >
                                                        <option value="Level 1">Level 1</option>
                                                        <option value="Level 2">Level 2</option>
                                                        <option value="Level 3">Level 3</option>
                                                        <option value="Level 4">Level 4</option>
                                                    </select>
                                                </div>

                                                <button onClick={handleGenerate} disabled={isProcessing} className="w-full bg-black text-white py-4 font-bold rounded-2xl flex items-center justify-center gap-3 hover:bg-gray-800 disabled:opacity-50 transition-all shadow-md">
                                                    {isProcessing ? <Spinner /> : "Generate transcript"}
                                                </button>
                                                
                                                {processingError && (
                                                    <div className="p-4 bg-red-50 text-red-600 text-xs font-bold rounded-xl border border-red-100 text-center animate-pulse">
                                                        Error: {processingError}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="space-y-4 fade-in">
                                            <SmartPlayer source={source} isPlaying={isPlaying} setIsPlaying={setIsPlaying} seekTime={currentTime} onTimeUpdate={handleTimeUpdate} loopRange={loopRange} seekTrigger={seekTrigger} />
                                            
                                            <div className="bg-white border border-gray-100 p-4 rounded-2xl shadow-sm flex items-center justify-between px-6 transition-all">
                                                <div className="flex items-center gap-4">
                                                    <button onClick={() => { setIsPlaying(!isPlaying); stopAtTimeRef.current = null; }} className="w-10 h-10 bg-black text-white flex items-center justify-center rounded-full hover:scale-105 active:scale-95 transition-all">
                                                        {isPlaying ? <Pause size={18} /> : <Play size={18} className="ml-0.5" />}
                                                    </button>
                                                    <div className="font-mono text-xs font-bold text-gray-500 tabular-nums bg-gray-50 px-3 py-1 rounded-md border border-gray-100 min-w-[80px] text-center">
                                                        {formatTime(currentTime)}
                                                    </div>
                                                </div>
                                                <div className="flex items-center gap-3">
                                                    {loopRange && <button onClick={() => setLoopRange(null)} className="bg-indigo-600 text-white text-[10px] font-bold px-3 py-1.5 rounded-full animate-pulse flex items-center gap-1.5"><RefreshCw size={10} /> Stop loop</button>}
                                                    <button onClick={() => setSource(null)} className="text-[10px] font-bold text-red-500 hover:bg-red-50 px-3 py-1.5 rounded-md uppercase tracking-wider transition-colors border border-red-100">Close Session</button>
                                                </div>
                                            </div>

                                            <div className="bg-white border border-gray-100 rounded-3xl overflow-hidden shadow-sm flex flex-col mt-2">
                                                {/* 1. UPDATED TABS LIST (Removed Grammar, Added Summary) */}
                                                <div className="flex border-b bg-gray-50/50">
                                                    {['Shadowing', 'Dictation', 'Translation', 'Summary'].map(tab => (
                                                        <button key={tab} onClick={() => { 
                                                            setActiveTab(tab); 
                                                            autoCollapseTranscript(); 
                                                        }} className={`flex-1 py-4 text-[11px] font-bold border-b-2 transition-all ${activeTab === tab ? 'border-black text-black bg-white' : 'border-transparent text-gray-400 hover:text-gray-600'}`}>{tab}</button>
                                                    ))}
                                                </div>
                                                
                                                <div className="p-6 min-h-[400px]">
                                                    {/* --- SHADOWING TAB --- */}
                                                    {activeTab === 'Shadowing' && (
                                                        <div className="space-y-6 fade-in">
                                                            {/* 1. CONTROLS & NAVIGATION */}
                                                            <div className="flex flex-col space-y-4">
                                                                <div className="flex items-center justify-between px-1">
                                                                    <label className="text-xs font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2">
                                                                        <Layers size={12} /> Practice chunk size
                                                                    </label>
                                                                    <select value={chunkSize} onChange={(e) => setChunkSize(e.target.value)} className="text-xs font-bold border-none bg-gray-50 rounded-lg px-2 py-1 outline-none">
                                                                        <option value="single">Single sentence</option>
                                                                        <option value="5-8">5-8 seconds</option>
                                                                        <option value="15-18">15-18 seconds</option>
                                                                        <option value="30-35">30-35 seconds</option>
                                                                        <option value="60-65">60-65 seconds</option>
                                                                    </select>
                                                                </div>
                                                                <div className="grid grid-cols-3 gap-3">
                                                                    <button onClick={() => handleTranscriptSeek(activeIndex - 1)} className="flex items-center justify-center gap-2 px-4 py-3 bg-gray-50 hover:bg-gray-100 text-gray-700 rounded-xl transition-colors border border-gray-100 text-[10px] font-bold uppercase tracking-wider"><SkipBack size={14} /> Previous</button>
                                                                    <button onClick={() => handleTranscriptSeek(activeIndex)} className="flex items-center justify-center gap-2 px-4 py-3 bg-gray-50 hover:bg-gray-100 text-gray-700 rounded-xl transition-colors border border-gray-100 text-[10px] font-bold uppercase tracking-wider"><RefreshCw size={14} /> Current</button>
                                                                    <button onClick={() => handleTranscriptSeek(activeIndex + 1)} className="flex items-center justify-center gap-2 px-4 py-3 bg-gray-50 hover:bg-gray-100 text-gray-700 rounded-xl transition-colors border border-gray-100 text-[10px] font-bold uppercase tracking-wider">Next <SkipForward size={14} /></button>
                                                                </div>
                                                            </div>

                                                            {/* 2. NEW: TRANSCRIPT DISPLAY & TOGGLE */}
                                                            {/* 2. NEW: TRANSCRIPT DISPLAY & TOGGLE */}
                                                            <div className="space-y-4">
                                                                {showShadowingContent && (
                                                                    <div className="p-8 bg-gray-50 rounded-[2.5rem] border border-gray-100 min-h-[150px] flex flex-col items-center justify-center text-center transition-all animate-in fade-in slide-in-from-top-2">
                                                                        {chunkSize === 'single' ? (
                                                                            // MODE A: Single Sentence -> Interactive
                                                                            <div className="text-xl font-semibold text-gray-900 leading-relaxed">
                                                                                {transcript[activeIndex] ? (
                                                                                    <InteractiveText text={transcript[activeIndex].text} onWordClick={handleWordClick} />
                                                                                ) : (
                                                                                    <span className="text-gray-400 italic font-normal">Play audio to see text...</span>
                                                                                )}
                                                                            </div>
                                                                        ) : (
                                                                            // MODE B: Chunk Mode -> Interactive List
                                                                            <div className="w-full space-y-4 max-h-[300px] overflow-y-auto custom-scrollbar px-2">
                                                                                {visitedIndices.size === 0 ? (
                                                                                    <span className="text-gray-400 italic">Play audio to see transcript history...</span>
                                                                                ) : (
                                                                                    Array.from(visitedIndices).sort((a,b) => a-b).map(idx => (
                                                                                        <div key={idx} className={`text-lg leading-relaxed transition-colors ${idx === activeIndex ? 'font-bold text-gray-900' : 'text-gray-400'}`}>
                                                                                            <InteractiveText text={transcript[idx]?.text} onWordClick={handleWordClick} />
                                                                                        </div>
                                                                                    ))
                                                                                )}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                )}
                                                                
                                                                {/* Hide/Show Button */}
                                                                <div className="flex justify-center">
                                                                    <button 
                                                                        onClick={() => setShowShadowingContent(!showShadowingContent)} 
                                                                        className="px-6 py-2.5 bg-white border border-gray-200 text-gray-600 font-bold text-xs uppercase rounded-full hover:bg-gray-50 transition-all flex items-center gap-2 shadow-sm hover:shadow-md"
                                                                    >
                                                                        {showShadowingContent ? <><EyeOff size={14} /> Hide Transcript</> : <><Eye size={14} /> Show Transcript</>}
                                                                    </button>
                                                                </div>
                                                            </div>

                                                            {/* 3. RECORDING PANEL (Unchanged) */}
                                                            <div className="p-6 bg-gray-50 rounded-3xl border border-gray-100 space-y-4">
                                                                <div className="flex items-center justify-between">
                                                                    <h4 className="text-sm font-bold text-gray-600 flex items-center gap-2"><Mic size={16} /> Voice record</h4>
                                                                    {/* NEW: User Awareness Label */}
                                                                    <span className="text-[9px] font-bold text-gray-400 uppercase tracking-widest">Limit : 1 per sentence</span>
                                                                </div>
                                                                <div className="flex items-center gap-3">
                                                                    {!isRecording ? (
                                                                        <button onClick={startRecording} className="flex-1 flex items-center justify-center gap-2 py-3 bg-white border border-gray-200 text-gray-700 font-bold text-xs uppercase rounded-xl hover:bg-gray-100 transition-all"><Circle size={12} className="text-red-500 fill-current" /> Start recording</button>
                                                                    ) : (
                                                                        <button onClick={stopRecording} className="flex-1 flex items-center justify-center gap-2 py-3 bg-red-500 text-white font-bold text-xs uppercase rounded-xl hover:bg-red-600 transition-all animate-pulse"><Square size={12} className="fill-current" /> Stop recording</button>
                                                                    )}
                                                                    {recordedBlob && !isRecording && (
                                                                        <>
                                                                            <button onClick={() => togglePlayback(URL.createObjectURL(recordedBlob), 'unsaved_summary')} className={`p-4 border rounded-xl shadow-sm transition-colors ${playbackState.id === 'unsaved_summary' && playbackState.isPlaying ? 'bg-black text-white border-black' : 'bg-white border-gray-200 hover:bg-gray-100 text-black'}`}>
                                                                                {playbackState.id === 'unsaved_summary' && playbackState.isPlaying ? <Pause size={20} /> : <Play size={20} />}
                                                                            </button>
                                                                            <button onClick={saveRecording} disabled={isSavingRecord} className="px-5 py-3 bg-black text-white font-bold text-xs uppercase rounded-xl flex items-center gap-2">{isSavingRecord ? <Spinner /> : <Save size={16} />} Save</button>
                                                                        </>
                                                                    )}
                                                                </div>
                                                                
                                                                {/* Filter: Only show recordings for CURRENT SENTENCE in Shadowing */}
                                                            <div className="space-y-2 max-h-[200px] overflow-y-auto custom-scrollbar pt-2">
                                                                {recordingsList.filter(r => {
                                                                    // Match the specific prefix for this sentence
                                                                    const prefix = `Shadowing - ${source?.title} - S${activeIndex} -`;
                                                                    return r.title && r.title.startsWith(prefix);
                                                                }).map(rec => (
                                                                    <div key={rec.id} className="flex items-center justify-between p-3 bg-white border border-gray-100 rounded-xl shadow-sm">
                                                                        <div className="flex items-center gap-3">
                                                                            <button onClick={() => togglePlayback(rec.file_url, rec.id)} className={`p-2 rounded-lg transition-all ${playbackState.id === rec.id && playbackState.isPlaying ? 'bg-black text-white' : 'bg-gray-50 hover:bg-gray-100 text-black'}`}>
                                                                                {playbackState.id === rec.id && playbackState.isPlaying ? <Pause size={12} /> : <Play size={12} />}
                                                                            </button>
                                                                            <div className="flex flex-col">
                                                                                <span className="text-[10px] font-bold text-gray-800 truncate max-w-[150px]">Recording</span>
                                                                                <span className="text-[9px] text-gray-400">{new Date(rec.created_at).toLocaleTimeString()}</span>
                                                                            </div>
                                                                        </div>
                                                                        <button onClick={() => deleteRecording(rec.id)} className="p-2 text-gray-300 hover:text-red-500 transition-colors"><Trash2 size={14} /></button>
                                                                    </div>
                                                                ))}
                                                                {/* Show message if empty */}
                                                                {recordingsList.filter(r => r.title && r.title.startsWith(`Shadowing - ${source?.title} - S${activeIndex} -`)).length === 0 && (
                                                                    <div className="text-center py-4 text-xs text-gray-400 italic">No recordings for this sentence yet.</div>
                                                                )}
                                                            </div>
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* --- DICTATION TAB --- */}
                                                    {activeTab === 'Dictation' && (
                                                        <div className="p-10 bg-gray-50 rounded-[2.5rem] border border-gray-100 min-h-[300px] flex flex-col items-center justify-start overflow-y-auto custom-scrollbar gap-8">
                                                                {chunkSize === 'single' ? (
                                                                    // MODE A: Single Sentence (Original behavior)
                                                                    <div className="w-full">
                                                                        {showDictationContent && (
                                                                        <div className="w-full text-center px-6 py-4 mb-8 bg-white/50 rounded-2xl border border-gray-200 fade-in">
                                                                            <div className="text-lg font-semibold text-gray-900 leading-relaxed">
                                                                                <InteractiveText text={transcript[activeIndex]?.text} onWordClick={handleWordClick} />
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                        {renderDictationSlots(activeIndex)}
                                                                    </div>
                                                                ) : (
                                                                    // MODE B: Chunk Mode (Show all visited sentences)
                                                                    visitedIndices.size === 0 ? (
                                                                        <div className="flex flex-col items-center justify-center h-full pt-10 text-gray-400">
                                                                            <p className="italic">Play audio to start dictation...</p>
                                                                        </div>
                                                                    ) : (
                                                                        <div className="w-full space-y-12">
                                                                            {Array.from(visitedIndices).sort((a,b) => a - b).map(idx => (
                                                                                <div key={idx} className="w-full pb-8 border-b border-gray-200 last:border-0 fade-in">
                                                                                    {showDictationContent && (
                                                                        <div className="w-full text-center px-6 py-4 mb-8 bg-white/50 rounded-2xl border border-gray-200 fade-in">
                                                                            <div className="text-lg font-semibold text-gray-900 leading-relaxed">
                                                                                <InteractiveText text={transcript[activeIndex]?.text} onWordClick={handleWordClick} />
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                                    {renderDictationSlots(idx)}
                                                                                </div>
                                                                            ))}
                                                                        </div>
                                                                    )
                                                                )}
                                                            </div>
                                                    )}

                                                    {/* --- TRANSLATION TAB (Includes Grammar) --- */}
                                                    {activeTab === 'Translation' && (
                                                        <div className="h-full flex flex-col space-y-6 fade-in">
                                                            <div className="grid grid-cols-3 gap-3"><button onClick={() => handleTranscriptSeek(activeIndex - 1)} className="flex items-center justify-center gap-2 px-4 py-3 bg-gray-50 hover:bg-gray-100 text-gray-700 rounded-xl transition-colors border border-gray-100 text-[10px] font-bold uppercase tracking-wider"><SkipBack size={14} /> Previous</button><button onClick={() => handleTranscriptSeek(activeIndex)} className="flex items-center justify-center gap-2 px-4 py-3 bg-gray-50 hover:bg-gray-100 text-gray-700 rounded-xl transition-colors border border-gray-100 text-[10px] font-bold uppercase tracking-wider"><RefreshCw size={14} /> Current</button><button onClick={() => handleTranscriptSeek(activeIndex + 1)} className="flex items-center justify-center gap-2 px-4 py-3 bg-gray-50 hover:bg-gray-100 text-gray-700 rounded-xl transition-colors border border-gray-100 text-[10px] font-bold uppercase tracking-wider">Next <SkipForward size={14} /></button></div>
                                                            <div className="flex-1 flex flex-col gap-4">
                                                                <label className="text-xs font-bold text-gray-400 uppercase px-1 tracking-widest">Source sentence</label>
                                                                <div className="p-6 bg-gray-50 rounded-2xl border border-gray-100 text-lg font-semibold text-gray-900 leading-relaxed italic">
                                                                    {transcript[activeIndex] ? (
                                                                        <InteractiveText text={transcript[activeIndex].text} onWordClick={handleWordClick} />
                                                                    ) : "Select a segment to practice"}
                                                                </div>                                                                
                                                                <label className="text-xs font-bold text-gray-400 uppercase px-1 tracking-widest">Your translation</label>
                                                                <textarea className="w-full p-6 bg-white border border-gray-200 rounded-3xl text-lg outline-none focus:ring-2 focus:ring-indigo-500 min-h-[120px] transition-all" placeholder="Type your translation here..." value={translationAttempt} onChange={(e) => setTranslationAttempt(e.target.value)} />
                                                                
                                                                <div className="flex gap-4">
                                                                    <button 
                                                                        onClick={() => { if (!analysis) triggerAnalysis(); setShowTranslationAnswer(true); }} 
                                                                        disabled={isAnalyzing}
                                                                        className="flex-1 py-4 bg-black text-white font-bold rounded-2xl shadow-lg hover:bg-gray-800 transition-all flex items-center justify-center gap-2 disabled:opacity-70 disabled:cursor-wait"
                                                                    >
                                                                        {isAnalyzing ? (
                                                                            <><Loader2 className="animate-spin w-5 h-5" /> Analyzing...</>
                                                                        ) : (
                                                                            <><CheckCircle2 size={18} /> Check & Show Answer</>
                                                                        )}
                                                                    </button>
                                                                    <button onClick={() => { setTranslationAttempt(""); setShowTranslationAnswer(false); }} className="px-8 py-4 bg-gray-100 text-gray-600 font-bold rounded-2xl hover:bg-gray-200 transition-all">Reset</button>
                                                                </div>

                                                                {showTranslationAnswer && analysis && (
                                                                    <div className="mt-6 space-y-4 fade-in pb-10">
                                                                        <div className="p-5 bg-emerald-50 text-emerald-900 border border-emerald-100 rounded-2xl">
                                                                            <h5 className="text-[10px] font-bold uppercase tracking-widest mb-2 opacity-60 text-emerald-700 flex items-center gap-2"><Languages size={12}/> Translation</h5>
                                                                            <p className="text-sm font-medium leading-relaxed">{analysis.translation || analysis.meaning}</p>
                                                                        </div>
                                                                        <div className="p-5 bg-blue-50 text-blue-900 border border-blue-100 rounded-2xl">
                                                                            <h5 className="text-[10px] font-bold uppercase tracking-widest mb-2 opacity-60 text-blue-700 flex items-center gap-2"><BookOpen size={12}/> Explanation</h5>
                                                                            <p className="text-sm font-normal leading-relaxed">{analysis.explanation || "No explanation provided."}</p>
                                                                        </div>
                                                                        <div className="p-5 bg-indigo-50 text-indigo-900 border border-indigo-100 rounded-2xl">
                                                                            <h5 className="text-[10px] font-bold uppercase tracking-widest mb-2 opacity-60 text-indigo-700 flex items-center gap-2"><Sparkles size={12}/> Grammar</h5>
                                                                            <p className="text-sm font-normal leading-relaxed whitespace-pre-wrap">{analysis.grammar}</p>
                                                                        </div>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* --- NEW SUMMARY TAB --- */}
                                                    {activeTab === 'Summary' && (
                                                        <div className="h-full flex flex-col space-y-6 fade-in p-2">
                                                            {visitedIndices.size < transcript.length ? (
                                                                // LOCKED VIEW
                                                                <div className="flex flex-col items-center justify-center py-20 text-gray-400 gap-6">
                                                                    <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center text-gray-300">
                                                                        <KeyRound size={32} />
                                                                    </div>
                                                                    <div className="text-center space-y-2">
                                                                        <h3 className="text-lg font-bold text-gray-900">Summary Locked</h3>
                                                                        <p className="text-sm max-w-xs mx-auto">You must listen to the full audio to unlock the summary feature.</p>
                                                                    </div>
                                                                    
                                                                    {/* Progress Bar */}
                                                                    <div className="w-full max-w-xs space-y-2">
                                                                        <div className="flex justify-between text-[10px] font-bold uppercase tracking-wider text-gray-500">
                                                                            <span>Progress</span>
                                                                            <span>{Math.round((visitedIndices.size / transcript.length) * 100)}%</span>
                                                                        </div>
                                                                        <div className="h-2 w-full bg-gray-100 rounded-full overflow-hidden">
                                                                            <div 
                                                                                className="h-full bg-black transition-all duration-500 ease-out" 
                                                                                style={{ width: `${(visitedIndices.size / transcript.length) * 100}%` }}
                                                                            />
                                                                        </div>
                                                                        <p className="text-[10px] text-center text-gray-400">{visitedIndices.size} of {transcript.length} sentences played</p>
                                                                    </div>
                                                                </div>
                                                            ) : (
                                                                // UNLOCKED VIEW
                                                                <div className="space-y-6 animate-in fade-in duration-500">
                                                                    <div className="bg-emerald-50 border border-emerald-100 p-6 rounded-3xl flex items-start gap-4">
                                                                        <div className="p-3 bg-emerald-100 text-emerald-700 rounded-xl"><Sparkles size={20} /></div>
                                                                        <div>
                                                                            <h3 className="font-bold text-emerald-900 text-lg">Great job!</h3>
                                                                            <p className="text-emerald-800 text-sm mt-1 leading-relaxed">You've listened to the entire audio. Now, please record a short verbal summary of what you just heard. Focus on the main ideas and key details.</p>
                                                                        </div>
                                                                    </div>

                                                                    <div className="p-6 bg-gray-50 rounded-3xl border border-gray-100 space-y-4">
                                                                        <div className="flex items-center justify-between"><h4 className="text-sm font-bold text-gray-600 flex items-center gap-2"><Mic size={16} /> Record Summary</h4><span className="text-[9px] font-bold text-gray-400 uppercase tracking-widest">Limit : 2 per audio</span></div>
                                                                        
                                                                        {/* Recorder Controls */}
                                                                        <div className="flex items-center gap-3">
                                                                            {!isRecording ? (
                                                                                <button onClick={startRecording} className="flex-1 flex items-center justify-center gap-2 py-4 bg-white border border-gray-200 text-gray-700 font-bold text-sm uppercase rounded-xl hover:bg-gray-100 transition-all shadow-sm">
                                                                                    <Circle size={14} className="text-red-500 fill-current" /> Start recording
                                                                                </button>
                                                                            ) : (
                                                                                <button onClick={stopRecording} className="flex-1 flex items-center justify-center gap-2 py-4 bg-red-500 text-white font-bold text-sm uppercase rounded-xl hover:bg-red-600 transition-all animate-pulse shadow-md">
                                                                                    <Square size={14} className="fill-current" /> Stop recording
                                                                                </button>
                                                                            )}
                                                                            
                                                                            {recordedBlob && !isRecording && (
                                                                                <>
                                                                                    <button onClick={() => togglePlayback(URL.createObjectURL(recordedBlob), 'unsaved_shadow')} className={`p-3 border rounded-xl transition-all ${playbackState.id === 'unsaved_shadow' && playbackState.isPlaying ? 'bg-black text-white border-black' : 'bg-white border-gray-200 hover:bg-gray-100 text-black'}`}>
                                                                                        {playbackState.id === 'unsaved_shadow' && playbackState.isPlaying ? <Pause size={16} /> : <Play size={16} />}
                                                                                    </button>
                                                                                    <button onClick={saveSummaryRecording} disabled={isSavingRecord} className="px-6 py-4 bg-black text-white font-bold text-sm uppercase rounded-xl flex items-center gap-2 shadow-lg hover:bg-gray-800 transition-all">
                                                                                        {isSavingRecord ? <Spinner /> : <Save size={18} />} Save
                                                                                    </button>
                                                                                </>
                                                                            )}
                                                                        </div>

                                                                        {/* Summary Recordings List (Filtered) */}
                                                                        <div className="space-y-2 pt-2">
                                                                            {recordingsList.filter(r => r.title.startsWith(`Summary - ${source.title}`)).length === 0 && (
                                                                                <p className="text-center text-xs text-gray-400 py-4 italic">No summaries recorded yet.</p>
                                                                            )}
                                                                            {recordingsList.filter(r => r.title.startsWith(`Summary - ${source.title}`)).map(rec => (
                                                                                <div key={rec.id} className="flex items-center justify-between p-4 bg-white border border-gray-100 rounded-xl shadow-sm hover:border-gray-300 transition-all">
                                                                                    <div className="flex items-center gap-3">
                                                                                        <button onClick={() => togglePlayback(rec.file_url, rec.id)} className={`p-2 rounded-lg transition-all ${playbackState.id === rec.id && playbackState.isPlaying ? 'bg-red-500 text-white' : 'bg-black text-white hover:bg-gray-800'}`}>
                                                                                            {playbackState.id === rec.id && playbackState.isPlaying ? <Pause size={12} /> : <Play size={12} />}
                                                                                        </button>
                                                                                        <div className="flex flex-col">
                                                                                            <span className="text-xs font-bold text-gray-800">Summary</span>
                                                                                            <span className="text-[10px] text-gray-400">{new Date(rec.created_at).toLocaleString()}</span>
                                                                                        </div>
                                                                                    </div>
                                                                                    <button onClick={() => deleteRecording(rec.id)} className="p-2 text-gray-300 hover:text-red-500 transition-colors"><Trash2 size={16} /></button>
                                                                                </div>
                                                                            ))}
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </main>

                        <aside className={`
                            bg-white flex flex-col overflow-hidden
                            ${isMobile 
                                /* Mobile: Bottom Sheet (60% Height, Slide Up/Down) */
                                ? `fixed inset-x-0 bottom-0 z-40 w-full h-[60vh] rounded-t-3xl shadow-[0_-8px_30px_rgba(0,0,0,0.12)] transition-transform duration-300 ease-out ${transcriptOpen ? 'translate-y-0' : 'translate-y-full'}`
                                /* Desktop: Side Panel (Full Height, Slide Left/Right) */
                                : `relative h-full transition-all duration-300 ease-in-out border-l ${transcriptOpen ? 'w-[450px] translate-x-0' : 'w-0 translate-x-full lg:w-0 lg:border-none'}`
                            }
                        `}>
                            <div className="p-4 border-b bg-gray-50 flex justify-between items-center whitespace-nowrap w-full md:min-w-[450px]">
                                <h2 className="font-bold text-sm text-gray-600 flex items-center gap-2"><FileText size={16} /> Full Transcript</h2>
                                <div className="flex items-center gap-2">
                                    <button onClick={() => { setFixPanelMode('ai'); setFixPanelOpen(!fixPanelOpen); }} title="AI Fix Tools" className={`p-2 rounded-lg transition-all ${fixPanelOpen && fixPanelMode === 'ai' ? 'bg-red-100 text-red-600' : 'text-gray-400 hover:text-red-500'}`}><Wand2 size={18} /></button>
                                    <button onClick={() => setTranscriptOpen(false)} className="p-1.5 rounded-lg text-gray-400 transition-colors"><ChevronRight size={18} /></button>
                                </div>
                            </div>
                            <div className="flex-1 overflow-y-auto p-4 space-y-4 w-full md:min-w-[450px] custom-scrollbar pb-24 bg-gray-50/30">
                                <div className="text-[10px] text-gray-400 font-medium px-2 mb-2 italic flex justify-between items-center">
                                    <span>Tip: Use Ctrl+Shift to multiselect</span>
                                    {selectedIndices.length > 0 && <button onClick={() => { setSelectedIndices([]); setLastSelectedIndex(null); }} className="text-indigo-600 font-bold hover:underline">Clear Selection</button>}
                                </div>
                                {transcript.map((s, idx) => {
                                    const isSelected = selectedIndices.includes(idx);
                                    const isActive = activeIndex === idx;
                                    return (
                                        <div key={idx} id={`transcript-item-${idx}`} /* <--- ADD THIS ID */ onClick={(e) => handleSidebarClick(e, idx)} className={`group p-4 rounded-xl cursor-pointer transition-all border-2 flex gap-3 relative ${isSelected ? 'bg-indigo-600 border-indigo-600 text-white shadow-lg z-10' : isActive ? 'bg-black border-black text-white shadow-md' : 'bg-white border-transparent hover:border-gray-100 text-gray-500 shadow-sm'}`}>
                                            <div className="pt-0.5 shrink-0"><div className={`w-5 h-5 rounded-md border flex items-center justify-center transition-all ${isSelected ? 'bg-white border-white text-indigo-600' : isActive ? 'bg-white/20 border-white/40 text-transparent' : 'bg-gray-50 border-gray-200 text-transparent group-hover:border-gray-300'}`}>{isSelected && <Check size={14} strokeWidth={4} className="fade-in" />}</div></div>
                                            <div className="flex-1 min-w-0">
                                                <div className="flex justify-between items-center mb-1 text-[9px] font-bold uppercase tracking-wider opacity-60"><span>{s.speaker || 'Speaker'}</span><span>{formatTime(s.start)} - {formatTime(s.end)}</span></div>
                                                <p className="text-sm font-medium leading-relaxed pr-8">{s.text}</p>
                                                
                                                {/* Action Buttons */}
                                                <div className={`absolute right-3 bottom-3 flex gap-1 ${isSelected || isActive ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'} transition-opacity`}>
                                                    <button title="Edit Timestamp" onClick={(e) => handleManualEditOpen(e, idx)} className={`p-1.5 rounded-lg transition-all ${isSelected ? 'bg-white/20 text-white hover:bg-white/30' : isActive ? 'bg-white/20 text-white hover:bg-white/30' : 'bg-gray-100 text-gray-600 hover:bg-indigo-100 hover:text-indigo-600'}`}>
                                                        <Pencil size={14} />
                                                    </button>
                                                    {(isSelected || isActive) && (<button title="Select all after" onClick={(e) => { e.stopPropagation(); selectAllAfter(idx); }} className={`p-1.5 rounded-lg transition-all ${isSelected ? 'bg-white/20 text-white' : isActive ? 'bg-white/20 text-white' : 'bg-gray-100 text-gray-600'}`}><ListChecks size={14} /></button>)}
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </aside>
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>