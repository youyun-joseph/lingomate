<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LingoMate - Language Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f9fafb; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        .fade-in { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        
        .dictation-input {
            width: 2rem;
            height: 2.5rem;
            text-align: center;
            border-bottom: 2px solid #e5e7eb;
            background: transparent;
            font-size: 1.125rem;
            font-weight: 600;
            outline: none;
            transition: all 0.2s;
        }
        .dictation-input:focus { border-bottom-color: #000; background: #f9fafb; }
        .dictation-input.correct { color: #059669; border-bottom-color: #059669; }
        .dictation-input.incorrect { color: #dc2626; border-bottom-color: #dc2626; }
        
        .active-sentence {
            background-color: #f3f4f6;
            border-left: 4px solid black;
            padding-left: 12px;
            margin-left: -16px;
        }
    </style>
</head>
<body class="bg-white text-gray-900 h-screen flex flex-col overflow-hidden selection:bg-indigo-100 selection:text-indigo-900">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'https://esm.sh/react@18.3.1';
        import { createRoot } from 'https://esm.sh/react-dom@18.3.1/client';
        import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
        // ADDED Sparkles to imports
        import { 
            Play, Pause, ChevronRight, ChevronLeft, 
            Upload, FileText, History, Settings, 
            Mic, Volume2, User, LogOut, Loader2, X, Database, Save, AlertCircle, 
            CheckCircle2, AlertTriangle, Trash2, SkipBack, SkipForward, RefreshCw, 
            BookOpen, Layers, Square, Circle, Eye, Book, Wand2, Check, ListChecks, Share2, Sparkles 
        } from 'https://esm.sh/lucide-react@0.344.0?deps=react@18.3.1';

        const SUPABASE_URL = 'https://tnwtvxmbjwbgiwruttju.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRud3R2eG1iandiZ2l3cnV0dGp1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU2NjYzNzgsImV4cCI6MjA4MTI0MjM3OH0.3AexQNzabxTLV2PbkusFwSZe7n1jsYDBJF7GB2SXhRk';
        const DEFAULT_API_KEY = "AIzaSyArbJjcdPrq74ABOW0jzL_xOh-xY0-JFQ0"; 

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- UTILS & HELPERS ---
        const Spinner = () => <Loader2 className="w-4 h-4 animate-spin" />;
        const sanitizeFilename = (filename) => filename.replace(/[^a-z0-9.]/gi, '_').replace(/_+/g, '_');

        const getMediaDuration = (file) => new Promise((resolve) => {
            const url = URL.createObjectURL(file);
            const media = file.type.startsWith('video/') ? document.createElement('video') : document.createElement('audio');
            media.src = url;
            media.onloadedmetadata = () => { resolve(media.duration); };
            media.onerror = () => resolve(0);
        });

        const fileToGenerativePart = async (file) => {
            const base64 = await new Promise(r => {
                const reader = new FileReader();
                reader.onloadend = () => r(reader.result.split(',')[1]);
                reader.readAsDataURL(file);
            });
            return { inlineData: { data: base64, mimeType: file.type || 'application/octet-stream' } };
        };

        const formatTime = (s) => {
            if (s === undefined || s === null) return "0:00";
            return `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;
        };

        // --- STRICT CHAINING SANITIZER ---
        const sanitizeTranscript = (rawSegments, totalDuration) => {
            if (!Array.isArray(rawSegments) || rawSegments.length === 0) return [];
            
            // 1. Sort strictly
            const sorted = rawSegments.sort((a, b) => a.start - b.start);
            let nextStartPoint = 0.0;

            return sorted.map((seg, index) => {
                let start = Number(seg.start);
                let end = Number(seg.end);

                // A. START TIME LOGIC
                // First sentence MUST start at 0
                if (index === 0) {
                    start = 0.0; 
                } else {
                    // All others start exactly where previous ended
                    start = nextStartPoint;
                }

                // B. END TIME LOGIC (Strict Chaining)
                // We add a tiny buffer (0.05s) to capture the tail of the current sentence.
                // This 'end' will become the 'start' of the NEXT sentence.
                end = end + 0.05;

                // C. CHAINING
                nextStartPoint = end;

                // D. CLAMPING
                // If it's the last segment or goes past total duration, clamp it.
                if (totalDuration > 0 && (index === sorted.length - 1 || end > totalDuration)) {
                    end = totalDuration;
                    nextStartPoint = totalDuration; // Ensure loop closes
                }
                
                // Sanity check
                if (end <= start) end = start + 0.5;

                return { start, end, text: seg.text, speaker: seg.speaker || "Speaker" };
            });
        };

        const callGemini = async (apiKey, model, body) => {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error.message);
            if (!data.candidates) throw new Error("No response from AI");
            return data;
        };

        const processTranscription = async (apiKey, fileObject = null, contextText = "", totalDuration = 0) => {
            const effectiveKey = apiKey || DEFAULT_API_KEY;
            let parts = [];
            const durationStr = totalDuration ? `${totalDuration.toFixed(2)}` : "unknown";

            if (fileObject) {
                const filePart = await fileToGenerativePart(fileObject);
                // PROMPT: From Success Example (App.jsx)
                parts = [filePart, { text: `You are a professional transcriber tool. 
I will provide an audio or video file. 
Your task is to transcribe it into English and provide precise timestamps for the start and end of every sentence.

STRICT REQUIREMENTS:
1. Output strictly a VALID JSON array of objects.
2. Format: [ { "text": "string", "start": number, "end": number } ]
3. Do not split sentences on abbreviations (e.g. Mr., Dr.).
4. Transcription must be verbatim.
                
Output JSON:` }];
            }

            let rawText = "";
            try {
                // MODEL: gemini-2.5-flash-preview-09-2025 (Strictly following success example)
                const data = await callGemini(effectiveKey, "gemini-2.5-flash-preview-09-2025", { 
                    contents: [{ parts: parts }], 
                    generationConfig: { temperature: 0.0, responseMimeType: "application/json" } 
                });
                rawText = data.candidates[0].content.parts[0].text;
            } catch (err) {
                console.warn("Gemini 2.5 failed, attempting fallback", err);
                // Fallback only if 2.5 fails unexpectedly
                const data = await callGemini(effectiveKey, "gemini-2.0-flash-exp", { 
                    contents: [{ parts: parts }], 
                    generationConfig: { temperature: 0.0, responseMimeType: "application/json" } 
                });
                rawText = data.candidates[0].content.parts[0].text;
            }
            
            let rawJson = [];
            try {
                const cleanText = rawText.replace(/```json|```/g, '').trim();
                rawJson = JSON.parse(cleanText);
            } catch (e) {
                const match = rawText.match(/\[.*\]/s);
                if (match) {
                    try { rawJson = JSON.parse(match[0]); } catch (e2) {}
                }
            }

            if (!Array.isArray(rawJson) || rawJson.length === 0) {
                 throw new Error("Failed to parse transcript. Please try again.");
            }

            return sanitizeTranscript(rawJson, totalDuration);
        };

        const SmartPlayer = ({ source, isPlaying, setIsPlaying, seekTime, onTimeUpdate, stopAtTime, setStopAtTime }) => {
            const mediaRef = useRef(null);

            useEffect(() => {
                if (mediaRef.current) {
                    if (isPlaying) mediaRef.current.play().catch(e => console.error("Play error:", e));
                    else mediaRef.current.pause();
                }
            }, [isPlaying]);

            useEffect(() => {
                if (mediaRef.current && seekTime !== undefined && Math.abs(mediaRef.current.currentTime - seekTime) > 0.5) {
                    mediaRef.current.currentTime = seekTime;
                }
            }, [seekTime]);

            const handleTimeUpdate = (e) => {
                const t = e.target.currentTime;
                onTimeUpdate(t);
                if (stopAtTime !== null && t >= stopAtTime) {
                    setIsPlaying(false);
                    setStopAtTime(null);
                }
            };

            if (source.mediaType === 'video') {
                return (
                    <div className="w-full aspect-video bg-black rounded-3xl overflow-hidden shadow-2xl relative border-4 border-white mb-4">
                        <video 
                            ref={mediaRef} 
                            src={source.url} 
                            className="w-full h-full object-contain"
                            onTimeUpdate={handleTimeUpdate}
                        />
                    </div>
                );
            }

            return (
                <audio 
                    ref={mediaRef} 
                    src={source.url} 
                    onTimeUpdate={handleTimeUpdate}
                />
            );
        };

        function App() {
            const [user, setUser] = useState(null);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [source, setSource] = useState(null);
            const [transcript, setTranscript] = useState([]);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [stopAtTime, setStopAtTime] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingError, setProcessingError] = useState(null);
            const [geminiKey, setGeminiKey] = useState("");
            const [activeTab, setActiveTab] = useState('Transcript');

            const [history, setHistory] = useState([]);

            const activeIndex = transcript.findIndex((s, idx) => {
                return currentTime >= s.start && currentTime < s.end;
            });

            const transcriptRef = useRef(null);
            useEffect(() => {
                if (activeIndex !== -1 && transcriptRef.current) {
                    const activeEl = transcriptRef.current.children[activeIndex];
                    if (activeEl) {
                        activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }, [activeIndex]);

            useEffect(() => {
                const init = async () => {
                    const { data: { user } } = await supabase.auth.getUser();
                    setUser(user);
                    if(user) fetchSettings(user.id);
                };
                init();
            }, []);

            const fetchSettings = async (uid) => {
                const { data } = await supabase.from('user_settings').select('gemini_api_key').eq('user_id', uid).single();
                if (data?.gemini_api_key) setGeminiKey(data.gemini_api_key);
            };

            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const url = URL.createObjectURL(file);
                const duration = await getMediaDuration(file);
                setSource({ type: 'file', mediaType: file.type.startsWith('audio/') ? 'audio' : 'video', url, title: file.name, fileData: file, duration });
                setTranscript([]); setIsPlaying(false);
            };

            const handleGenerate = async () => {
                if (!source) return;
                setIsProcessing(true);
                setProcessingError(null);
                try {
                    const result = await processTranscription(geminiKey, source.fileData, source.title, source.duration || 0);
                    setTranscript(result);
                } catch (err) { 
                    setProcessingError(err.message); 
                }
                setIsProcessing(false);
            };

            const handleTranscriptClick = (seg) => {
                setCurrentTime(seg.start);
                setStopAtTime(seg.end); 
                setIsPlaying(true);
            };

            const SettingsModal = ({ isOpen, onClose, apiKey, onSave }) => {
                const [key, setKey] = useState(apiKey || '');
                if (!isOpen) return null;
                return (
                    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/40 backdrop-blur-sm">
                        <div className="bg-white w-full max-w-md rounded-2xl p-6 shadow-2xl">
                            <h2 className="font-bold text-lg mb-4">Settings</h2>
                            <input type="password" placeholder="Gemini API Key" className="w-full border p-2 rounded mb-4" value={key} onChange={e => setKey(e.target.value)} />
                            <div className="flex gap-2">
                                <button onClick={onClose} className="flex-1 py-2 bg-gray-100 rounded-lg">Cancel</button>
                                <button onClick={() => { onSave(key); onClose(); }} className="flex-1 py-2 bg-black text-white rounded-lg">Save</button>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="h-full flex flex-col font-sans text-gray-900 bg-gray-50 overflow-hidden">
                    <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} apiKey={geminiKey} onSave={setGeminiKey} />
                    
                    <header className="bg-white px-6 py-4 flex justify-between items-center shadow-sm z-10">
                        <div className="flex items-center gap-2">
                            <div className="bg-black p-1.5 rounded"><Sparkles className="text-white w-4 h-4" /></div>
                            <h1 className="font-bold text-lg tracking-tight">LingoMate <span className="font-normal text-gray-400 text-sm">| AI Audio Alignment</span></h1>
                        </div>
                        <button onClick={() => setIsSettingsOpen(true)} className="p-2 hover:bg-gray-100 rounded-full"><Settings className="w-5 h-5 text-gray-600" /></button>
                    </header>

                    <div className="flex-1 flex overflow-hidden">
                        <main className="flex-1 flex flex-col p-6 overflow-y-auto custom-scrollbar">
                            {!source ? (
                                <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-gray-300 rounded-3xl m-4 hover:bg-gray-50 transition-colors">
                                    <Upload className="w-12 h-12 text-gray-300 mb-4" />
                                    <p className="text-gray-500 font-medium">Upload Audio/Video to Start</p>
                                    <input type="file" className="hidden" id="file-upload" accept="video/*,audio/*" onChange={handleFileUpload} />
                                    <label htmlFor="file-upload" className="mt-4 px-6 py-3 bg-black text-white rounded-xl font-bold cursor-pointer hover:bg-gray-800 transition-all shadow-lg">Select File</label>
                                </div>
                            ) : (
                                <div className="max-w-3xl mx-auto w-full space-y-6">
                                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-gray-100">
                                        <div className="flex items-center justify-between mb-4">
                                            <h2 className="font-bold text-gray-800 truncate pr-4">{source.title}</h2>
                                            <button onClick={() => { setSource(null); setTranscript([]); }} className="text-xs font-bold text-red-500 bg-red-50 px-3 py-1.5 rounded-full hover:bg-red-100">CLOSE</button>
                                        </div>
                                        
                                        <SmartPlayer 
                                            source={source} 
                                            isPlaying={isPlaying} 
                                            setIsPlaying={setIsPlaying} 
                                            seekTime={currentTime} 
                                            onTimeUpdate={handleTimeUpdate}
                                            stopAtTime={stopAtTime}
                                            setStopAtTime={setStopAtTime}
                                        />

                                        <div className="flex justify-center gap-6 mt-4">
                                            <button onClick={() => setIsPlaying(!isPlaying)} className="w-14 h-14 bg-black text-white rounded-full flex items-center justify-center hover:scale-105 transition-transform shadow-xl">
                                                {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6 ml-1" />}
                                            </button>
                                        </div>
                                    </div>

                                    {transcript.length === 0 && (
                                        <div className="text-center py-10">
                                            <button onClick={handleGenerate} disabled={isProcessing} className="px-8 py-4 bg-black text-white font-bold rounded-2xl shadow-xl hover:bg-gray-800 disabled:opacity-50 flex items-center gap-2 mx-auto">
                                                {isProcessing ? <Spinner /> : <Wand2 className="w-5 h-5" />}
                                                {isProcessing ? "Transcribing with Gemini 2.5..." : "Generate Transcript"}
                                            </button>
                                            {processingError && <p className="text-red-500 text-sm mt-4 font-bold bg-red-50 p-2 rounded-lg inline-block">{processingError}</p>}
                                        </div>
                                    )}
                                </div>
                            )}
                        </main>

                        {transcript.length > 0 && (
                            <aside className="w-[400px] bg-white border-l border-gray-200 flex flex-col shadow-xl z-20">
                                <div className="p-4 border-b border-gray-100 bg-gray-50/50 flex justify-between items-center">
                                    <h3 className="font-bold text-gray-700 flex items-center gap-2"><FileText className="w-4 h-4" /> Transcript</h3>
                                    <span className="text-xs font-mono text-gray-400">{transcript.length} segments</span>
                                </div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-2" ref={transcriptRef}>
                                    {transcript.map((seg, idx) => {
                                        const isActive = idx === activeIndex;
                                        return (
                                            <div 
                                                key={idx} 
                                                onClick={() => handleTranscriptClick(seg)}
                                                className={`p-4 rounded-xl cursor-pointer transition-all border-l-4 group ${isActive ? 'bg-indigo-50 border-indigo-600 shadow-md' : 'bg-white border-transparent hover:bg-gray-50 hover:border-gray-200'}`}
                                            >
                                                <div className="flex justify-between items-center mb-1">
                                                    <span className={`text-[10px] font-bold uppercase tracking-wider ${isActive ? 'text-indigo-600' : 'text-gray-400'}`}>
                                                        {formatTime(seg.start)} - {formatTime(seg.end)}
                                                    </span>
                                                    {isActive && <div className="w-2 h-2 bg-indigo-600 rounded-full animate-pulse"></div>}
                                                </div>
                                                <p className={`text-sm leading-relaxed ${isActive ? 'text-gray-900 font-medium' : 'text-gray-500'}`}>
                                                    {seg.text}
                                                </p>
                                            </div>
                                        );
                                    })}
                                </div>
                            </aside>
                        )}
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>